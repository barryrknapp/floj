// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: paymentchannel.proto

package org.flo.paymentchannel;

public final class Protos {
  private Protos() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public interface TwoWayChannelMessageOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.TwoWayChannelMessage)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * This is required so if a new message type is added in future, old software aborts trying
     * to read the message as early as possible. If the message doesn't parse, the socket should
     * be closed.
     * </pre>
     *
     * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
     */
    boolean hasType();
    /**
     * <pre>
     * This is required so if a new message type is added in future, old software aborts trying
     * to read the message as early as possible. If the message doesn't parse, the socket should
     * be closed.
     * </pre>
     *
     * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
     */
    org.flo.paymentchannel.Protos.TwoWayChannelMessage.MessageType getType();

    /**
     * <pre>
     * Now one optional field for each message. Only the field specified by type should be read.
     * </pre>
     *
     * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
     */
    boolean hasClientVersion();
    /**
     * <pre>
     * Now one optional field for each message. Only the field specified by type should be read.
     * </pre>
     *
     * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
     */
    org.flo.paymentchannel.Protos.ClientVersion getClientVersion();

    /**
     * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
     */
    boolean hasServerVersion();
    /**
     * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
     */
    org.flo.paymentchannel.Protos.ServerVersion getServerVersion();

    /**
     * <code>optional .paymentchannels.Initiate initiate = 4;</code>
     */
    boolean hasInitiate();
    /**
     * <code>optional .paymentchannels.Initiate initiate = 4;</code>
     */
    org.flo.paymentchannel.Protos.Initiate getInitiate();

    /**
     * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
     */
    boolean hasProvideRefund();
    /**
     * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
     */
    org.flo.paymentchannel.Protos.ProvideRefund getProvideRefund();

    /**
     * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
     */
    boolean hasReturnRefund();
    /**
     * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
     */
    org.flo.paymentchannel.Protos.ReturnRefund getReturnRefund();

    /**
     * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
     */
    boolean hasProvideContract();
    /**
     * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
     */
    org.flo.paymentchannel.Protos.ProvideContract getProvideContract();

    /**
     * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
     */
    boolean hasUpdatePayment();
    /**
     * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
     */
    org.flo.paymentchannel.Protos.UpdatePayment getUpdatePayment();

    /**
     * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
     */
    boolean hasPaymentAck();
    /**
     * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
     */
    org.flo.paymentchannel.Protos.PaymentAck getPaymentAck();

    /**
     * <code>optional .paymentchannels.Settlement settlement = 9;</code>
     */
    boolean hasSettlement();
    /**
     * <code>optional .paymentchannels.Settlement settlement = 9;</code>
     */
    org.flo.paymentchannel.Protos.Settlement getSettlement();

    /**
     * <code>optional .paymentchannels.Error error = 10;</code>
     */
    boolean hasError();
    /**
     * <code>optional .paymentchannels.Error error = 10;</code>
     */
    org.flo.paymentchannel.Protos.Error getError();
  }
  /**
   * <pre>
   * This message is designed to be either sent raw over the network (e.g. length prefixed) or embedded inside another
   * protocol that is being extended to support micropayments. In this file "primary" typically can be read as "client"
   * and "secondary" as "server".
   * </pre>
   *
   * Protobuf type {@code paymentchannels.TwoWayChannelMessage}
   */
  public  static final class TwoWayChannelMessage extends
      com.google.protobuf.GeneratedMessageLite<
          TwoWayChannelMessage, TwoWayChannelMessage.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.TwoWayChannelMessage)
      TwoWayChannelMessageOrBuilder {
    private TwoWayChannelMessage() {
      type_ = 1;
    }
    /**
     * Protobuf enum {@code paymentchannels.TwoWayChannelMessage.MessageType}
     */
    public enum MessageType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>CLIENT_VERSION = 1;</code>
       */
      CLIENT_VERSION(1),
      /**
       * <code>SERVER_VERSION = 2;</code>
       */
      SERVER_VERSION(2),
      /**
       * <code>INITIATE = 3;</code>
       */
      INITIATE(3),
      /**
       * <code>PROVIDE_REFUND = 4;</code>
       */
      PROVIDE_REFUND(4),
      /**
       * <code>RETURN_REFUND = 5;</code>
       */
      RETURN_REFUND(5),
      /**
       * <code>PROVIDE_CONTRACT = 6;</code>
       */
      PROVIDE_CONTRACT(6),
      /**
       * <pre>
       * Note that there are no optional fields set for CHANNEL_OPEN, it is sent from the
       * secondary to the primary to indicate that the provided contract was received,
       * verified, and broadcast successfully and the primary can now provide UPDATE messages
       * at will to begin paying secondary. If the channel is interrupted after the
       * CHANNEL_OPEN message (ie closed without an explicit CLOSE or ERROR) the primary may
       * reopen the channel by setting the contract transaction hash in its CLIENT_VERSION
       * message.
       * </pre>
       *
       * <code>CHANNEL_OPEN = 7;</code>
       */
      CHANNEL_OPEN(7),
      /**
       * <code>UPDATE_PAYMENT = 8;</code>
       */
      UPDATE_PAYMENT(8),
      /**
       * <pre>
       * Sent by the server to the client after an UPDATE_PAYMENT message is successfully processed.
       * </pre>
       *
       * <code>PAYMENT_ACK = 11;</code>
       */
      PAYMENT_ACK(11),
      /**
       * <pre>
       * Either side can send this message. If the client sends it to the server, then the server
       * takes the most recent signature it received in an UPDATE_PAYMENT and uses it to create a
       * valid transaction, which it then broadcasts on the network.
       * Once broadcast is complete, it sends back another CLOSE message with the settlement field set, containing
       * the final state of the contract.
       * The server is allowed to initiate settlement whenever it wants, in which case the client will
       * asynchronously receive a CLOSE message with the settlement field set. The server is also allowed
       * to send a CLOSE to mark the end of a connection without any settlement taking place, in which
       * case this is just an equivalent to a TCP FIN packet. An explicit end-of-protocol markers can be
       * useful when this protocol is embedded inside another.
       * </pre>
       *
       * <code>CLOSE = 9;</code>
       */
      CLOSE(9),
      /**
       * <pre>
       * Used to indicate an error condition.
       * Both parties should make an effort to send either an ERROR or a CLOSE immediately
       * before closing the socket (unless they just received an ERROR or a CLOSE). This is important
       * because the protocol may not run over TCP.
       * </pre>
       *
       * <code>ERROR = 10;</code>
       */
      ERROR(10),
      ;

      /**
       * <code>CLIENT_VERSION = 1;</code>
       */
      public static final int CLIENT_VERSION_VALUE = 1;
      /**
       * <code>SERVER_VERSION = 2;</code>
       */
      public static final int SERVER_VERSION_VALUE = 2;
      /**
       * <code>INITIATE = 3;</code>
       */
      public static final int INITIATE_VALUE = 3;
      /**
       * <code>PROVIDE_REFUND = 4;</code>
       */
      public static final int PROVIDE_REFUND_VALUE = 4;
      /**
       * <code>RETURN_REFUND = 5;</code>
       */
      public static final int RETURN_REFUND_VALUE = 5;
      /**
       * <code>PROVIDE_CONTRACT = 6;</code>
       */
      public static final int PROVIDE_CONTRACT_VALUE = 6;
      /**
       * <pre>
       * Note that there are no optional fields set for CHANNEL_OPEN, it is sent from the
       * secondary to the primary to indicate that the provided contract was received,
       * verified, and broadcast successfully and the primary can now provide UPDATE messages
       * at will to begin paying secondary. If the channel is interrupted after the
       * CHANNEL_OPEN message (ie closed without an explicit CLOSE or ERROR) the primary may
       * reopen the channel by setting the contract transaction hash in its CLIENT_VERSION
       * message.
       * </pre>
       *
       * <code>CHANNEL_OPEN = 7;</code>
       */
      public static final int CHANNEL_OPEN_VALUE = 7;
      /**
       * <code>UPDATE_PAYMENT = 8;</code>
       */
      public static final int UPDATE_PAYMENT_VALUE = 8;
      /**
       * <pre>
       * Sent by the server to the client after an UPDATE_PAYMENT message is successfully processed.
       * </pre>
       *
       * <code>PAYMENT_ACK = 11;</code>
       */
      public static final int PAYMENT_ACK_VALUE = 11;
      /**
       * <pre>
       * Either side can send this message. If the client sends it to the server, then the server
       * takes the most recent signature it received in an UPDATE_PAYMENT and uses it to create a
       * valid transaction, which it then broadcasts on the network.
       * Once broadcast is complete, it sends back another CLOSE message with the settlement field set, containing
       * the final state of the contract.
       * The server is allowed to initiate settlement whenever it wants, in which case the client will
       * asynchronously receive a CLOSE message with the settlement field set. The server is also allowed
       * to send a CLOSE to mark the end of a connection without any settlement taking place, in which
       * case this is just an equivalent to a TCP FIN packet. An explicit end-of-protocol markers can be
       * useful when this protocol is embedded inside another.
       * </pre>
       *
       * <code>CLOSE = 9;</code>
       */
      public static final int CLOSE_VALUE = 9;
      /**
       * <pre>
       * Used to indicate an error condition.
       * Both parties should make an effort to send either an ERROR or a CLOSE immediately
       * before closing the socket (unless they just received an ERROR or a CLOSE). This is important
       * because the protocol may not run over TCP.
       * </pre>
       *
       * <code>ERROR = 10;</code>
       */
      public static final int ERROR_VALUE = 10;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static MessageType valueOf(int value) {
        return forNumber(value);
      }

      public static MessageType forNumber(int value) {
        switch (value) {
          case 1: return CLIENT_VERSION;
          case 2: return SERVER_VERSION;
          case 3: return INITIATE;
          case 4: return PROVIDE_REFUND;
          case 5: return RETURN_REFUND;
          case 6: return PROVIDE_CONTRACT;
          case 7: return CHANNEL_OPEN;
          case 8: return UPDATE_PAYMENT;
          case 11: return PAYMENT_ACK;
          case 9: return CLOSE;
          case 10: return ERROR;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<MessageType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          MessageType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<MessageType>() {
              public MessageType findValueByNumber(int number) {
                return MessageType.forNumber(number);
              }
            };

      private final int value;

      private MessageType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:paymentchannels.TwoWayChannelMessage.MessageType)
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_;
    /**
     * <pre>
     * This is required so if a new message type is added in future, old software aborts trying
     * to read the message as early as possible. If the message doesn't parse, the socket should
     * be closed.
     * </pre>
     *
     * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
     */
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * This is required so if a new message type is added in future, old software aborts trying
     * to read the message as early as possible. If the message doesn't parse, the socket should
     * be closed.
     * </pre>
     *
     * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
     */
    public org.flo.paymentchannel.Protos.TwoWayChannelMessage.MessageType getType() {
      org.flo.paymentchannel.Protos.TwoWayChannelMessage.MessageType result = org.flo.paymentchannel.Protos.TwoWayChannelMessage.MessageType.forNumber(type_);
      return result == null ? org.flo.paymentchannel.Protos.TwoWayChannelMessage.MessageType.CLIENT_VERSION : result;
    }
    /**
     * <pre>
     * This is required so if a new message type is added in future, old software aborts trying
     * to read the message as early as possible. If the message doesn't parse, the socket should
     * be closed.
     * </pre>
     *
     * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
     */
    private void setType(org.flo.paymentchannel.Protos.TwoWayChannelMessage.MessageType value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000001;
      type_ = value.getNumber();
    }
    /**
     * <pre>
     * This is required so if a new message type is added in future, old software aborts trying
     * to read the message as early as possible. If the message doesn't parse, the socket should
     * be closed.
     * </pre>
     *
     * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
     */
    private void clearType() {
      bitField0_ = (bitField0_ & ~0x00000001);
      type_ = 1;
    }

    public static final int CLIENT_VERSION_FIELD_NUMBER = 2;
    private org.flo.paymentchannel.Protos.ClientVersion clientVersion_;
    /**
     * <pre>
     * Now one optional field for each message. Only the field specified by type should be read.
     * </pre>
     *
     * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
     */
    public boolean hasClientVersion() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Now one optional field for each message. Only the field specified by type should be read.
     * </pre>
     *
     * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
     */
    public org.flo.paymentchannel.Protos.ClientVersion getClientVersion() {
      return clientVersion_ == null ? org.flo.paymentchannel.Protos.ClientVersion.getDefaultInstance() : clientVersion_;
    }
    /**
     * <pre>
     * Now one optional field for each message. Only the field specified by type should be read.
     * </pre>
     *
     * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
     */
    private void setClientVersion(org.flo.paymentchannel.Protos.ClientVersion value) {
      if (value == null) {
        throw new NullPointerException();
      }
      clientVersion_ = value;
      bitField0_ |= 0x00000002;
      }
    /**
     * <pre>
     * Now one optional field for each message. Only the field specified by type should be read.
     * </pre>
     *
     * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
     */
    private void setClientVersion(
        org.flo.paymentchannel.Protos.ClientVersion.Builder builderForValue) {
      clientVersion_ = builderForValue.build();
      bitField0_ |= 0x00000002;
    }
    /**
     * <pre>
     * Now one optional field for each message. Only the field specified by type should be read.
     * </pre>
     *
     * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
     */
    private void mergeClientVersion(org.flo.paymentchannel.Protos.ClientVersion value) {
      if (clientVersion_ != null &&
          clientVersion_ != org.flo.paymentchannel.Protos.ClientVersion.getDefaultInstance()) {
        clientVersion_ =
          org.flo.paymentchannel.Protos.ClientVersion.newBuilder(clientVersion_).mergeFrom(value).buildPartial();
      } else {
        clientVersion_ = value;
      }
      bitField0_ |= 0x00000002;
    }
    /**
     * <pre>
     * Now one optional field for each message. Only the field specified by type should be read.
     * </pre>
     *
     * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
     */
    private void clearClientVersion() {  clientVersion_ = null;
      bitField0_ = (bitField0_ & ~0x00000002);
    }

    public static final int SERVER_VERSION_FIELD_NUMBER = 3;
    private org.flo.paymentchannel.Protos.ServerVersion serverVersion_;
    /**
     * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
     */
    public boolean hasServerVersion() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
     */
    public org.flo.paymentchannel.Protos.ServerVersion getServerVersion() {
      return serverVersion_ == null ? org.flo.paymentchannel.Protos.ServerVersion.getDefaultInstance() : serverVersion_;
    }
    /**
     * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
     */
    private void setServerVersion(org.flo.paymentchannel.Protos.ServerVersion value) {
      if (value == null) {
        throw new NullPointerException();
      }
      serverVersion_ = value;
      bitField0_ |= 0x00000004;
      }
    /**
     * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
     */
    private void setServerVersion(
        org.flo.paymentchannel.Protos.ServerVersion.Builder builderForValue) {
      serverVersion_ = builderForValue.build();
      bitField0_ |= 0x00000004;
    }
    /**
     * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
     */
    private void mergeServerVersion(org.flo.paymentchannel.Protos.ServerVersion value) {
      if (serverVersion_ != null &&
          serverVersion_ != org.flo.paymentchannel.Protos.ServerVersion.getDefaultInstance()) {
        serverVersion_ =
          org.flo.paymentchannel.Protos.ServerVersion.newBuilder(serverVersion_).mergeFrom(value).buildPartial();
      } else {
        serverVersion_ = value;
      }
      bitField0_ |= 0x00000004;
    }
    /**
     * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
     */
    private void clearServerVersion() {  serverVersion_ = null;
      bitField0_ = (bitField0_ & ~0x00000004);
    }

    public static final int INITIATE_FIELD_NUMBER = 4;
    private org.flo.paymentchannel.Protos.Initiate initiate_;
    /**
     * <code>optional .paymentchannels.Initiate initiate = 4;</code>
     */
    public boolean hasInitiate() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional .paymentchannels.Initiate initiate = 4;</code>
     */
    public org.flo.paymentchannel.Protos.Initiate getInitiate() {
      return initiate_ == null ? org.flo.paymentchannel.Protos.Initiate.getDefaultInstance() : initiate_;
    }
    /**
     * <code>optional .paymentchannels.Initiate initiate = 4;</code>
     */
    private void setInitiate(org.flo.paymentchannel.Protos.Initiate value) {
      if (value == null) {
        throw new NullPointerException();
      }
      initiate_ = value;
      bitField0_ |= 0x00000008;
      }
    /**
     * <code>optional .paymentchannels.Initiate initiate = 4;</code>
     */
    private void setInitiate(
        org.flo.paymentchannel.Protos.Initiate.Builder builderForValue) {
      initiate_ = builderForValue.build();
      bitField0_ |= 0x00000008;
    }
    /**
     * <code>optional .paymentchannels.Initiate initiate = 4;</code>
     */
    private void mergeInitiate(org.flo.paymentchannel.Protos.Initiate value) {
      if (initiate_ != null &&
          initiate_ != org.flo.paymentchannel.Protos.Initiate.getDefaultInstance()) {
        initiate_ =
          org.flo.paymentchannel.Protos.Initiate.newBuilder(initiate_).mergeFrom(value).buildPartial();
      } else {
        initiate_ = value;
      }
      bitField0_ |= 0x00000008;
    }
    /**
     * <code>optional .paymentchannels.Initiate initiate = 4;</code>
     */
    private void clearInitiate() {  initiate_ = null;
      bitField0_ = (bitField0_ & ~0x00000008);
    }

    public static final int PROVIDE_REFUND_FIELD_NUMBER = 5;
    private org.flo.paymentchannel.Protos.ProvideRefund provideRefund_;
    /**
     * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
     */
    public boolean hasProvideRefund() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
     */
    public org.flo.paymentchannel.Protos.ProvideRefund getProvideRefund() {
      return provideRefund_ == null ? org.flo.paymentchannel.Protos.ProvideRefund.getDefaultInstance() : provideRefund_;
    }
    /**
     * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
     */
    private void setProvideRefund(org.flo.paymentchannel.Protos.ProvideRefund value) {
      if (value == null) {
        throw new NullPointerException();
      }
      provideRefund_ = value;
      bitField0_ |= 0x00000010;
      }
    /**
     * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
     */
    private void setProvideRefund(
        org.flo.paymentchannel.Protos.ProvideRefund.Builder builderForValue) {
      provideRefund_ = builderForValue.build();
      bitField0_ |= 0x00000010;
    }
    /**
     * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
     */
    private void mergeProvideRefund(org.flo.paymentchannel.Protos.ProvideRefund value) {
      if (provideRefund_ != null &&
          provideRefund_ != org.flo.paymentchannel.Protos.ProvideRefund.getDefaultInstance()) {
        provideRefund_ =
          org.flo.paymentchannel.Protos.ProvideRefund.newBuilder(provideRefund_).mergeFrom(value).buildPartial();
      } else {
        provideRefund_ = value;
      }
      bitField0_ |= 0x00000010;
    }
    /**
     * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
     */
    private void clearProvideRefund() {  provideRefund_ = null;
      bitField0_ = (bitField0_ & ~0x00000010);
    }

    public static final int RETURN_REFUND_FIELD_NUMBER = 6;
    private org.flo.paymentchannel.Protos.ReturnRefund returnRefund_;
    /**
     * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
     */
    public boolean hasReturnRefund() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
     */
    public org.flo.paymentchannel.Protos.ReturnRefund getReturnRefund() {
      return returnRefund_ == null ? org.flo.paymentchannel.Protos.ReturnRefund.getDefaultInstance() : returnRefund_;
    }
    /**
     * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
     */
    private void setReturnRefund(org.flo.paymentchannel.Protos.ReturnRefund value) {
      if (value == null) {
        throw new NullPointerException();
      }
      returnRefund_ = value;
      bitField0_ |= 0x00000020;
      }
    /**
     * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
     */
    private void setReturnRefund(
        org.flo.paymentchannel.Protos.ReturnRefund.Builder builderForValue) {
      returnRefund_ = builderForValue.build();
      bitField0_ |= 0x00000020;
    }
    /**
     * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
     */
    private void mergeReturnRefund(org.flo.paymentchannel.Protos.ReturnRefund value) {
      if (returnRefund_ != null &&
          returnRefund_ != org.flo.paymentchannel.Protos.ReturnRefund.getDefaultInstance()) {
        returnRefund_ =
          org.flo.paymentchannel.Protos.ReturnRefund.newBuilder(returnRefund_).mergeFrom(value).buildPartial();
      } else {
        returnRefund_ = value;
      }
      bitField0_ |= 0x00000020;
    }
    /**
     * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
     */
    private void clearReturnRefund() {  returnRefund_ = null;
      bitField0_ = (bitField0_ & ~0x00000020);
    }

    public static final int PROVIDE_CONTRACT_FIELD_NUMBER = 7;
    private org.flo.paymentchannel.Protos.ProvideContract provideContract_;
    /**
     * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
     */
    public boolean hasProvideContract() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
     */
    public org.flo.paymentchannel.Protos.ProvideContract getProvideContract() {
      return provideContract_ == null ? org.flo.paymentchannel.Protos.ProvideContract.getDefaultInstance() : provideContract_;
    }
    /**
     * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
     */
    private void setProvideContract(org.flo.paymentchannel.Protos.ProvideContract value) {
      if (value == null) {
        throw new NullPointerException();
      }
      provideContract_ = value;
      bitField0_ |= 0x00000040;
      }
    /**
     * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
     */
    private void setProvideContract(
        org.flo.paymentchannel.Protos.ProvideContract.Builder builderForValue) {
      provideContract_ = builderForValue.build();
      bitField0_ |= 0x00000040;
    }
    /**
     * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
     */
    private void mergeProvideContract(org.flo.paymentchannel.Protos.ProvideContract value) {
      if (provideContract_ != null &&
          provideContract_ != org.flo.paymentchannel.Protos.ProvideContract.getDefaultInstance()) {
        provideContract_ =
          org.flo.paymentchannel.Protos.ProvideContract.newBuilder(provideContract_).mergeFrom(value).buildPartial();
      } else {
        provideContract_ = value;
      }
      bitField0_ |= 0x00000040;
    }
    /**
     * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
     */
    private void clearProvideContract() {  provideContract_ = null;
      bitField0_ = (bitField0_ & ~0x00000040);
    }

    public static final int UPDATE_PAYMENT_FIELD_NUMBER = 8;
    private org.flo.paymentchannel.Protos.UpdatePayment updatePayment_;
    /**
     * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
     */
    public boolean hasUpdatePayment() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
     */
    public org.flo.paymentchannel.Protos.UpdatePayment getUpdatePayment() {
      return updatePayment_ == null ? org.flo.paymentchannel.Protos.UpdatePayment.getDefaultInstance() : updatePayment_;
    }
    /**
     * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
     */
    private void setUpdatePayment(org.flo.paymentchannel.Protos.UpdatePayment value) {
      if (value == null) {
        throw new NullPointerException();
      }
      updatePayment_ = value;
      bitField0_ |= 0x00000080;
      }
    /**
     * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
     */
    private void setUpdatePayment(
        org.flo.paymentchannel.Protos.UpdatePayment.Builder builderForValue) {
      updatePayment_ = builderForValue.build();
      bitField0_ |= 0x00000080;
    }
    /**
     * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
     */
    private void mergeUpdatePayment(org.flo.paymentchannel.Protos.UpdatePayment value) {
      if (updatePayment_ != null &&
          updatePayment_ != org.flo.paymentchannel.Protos.UpdatePayment.getDefaultInstance()) {
        updatePayment_ =
          org.flo.paymentchannel.Protos.UpdatePayment.newBuilder(updatePayment_).mergeFrom(value).buildPartial();
      } else {
        updatePayment_ = value;
      }
      bitField0_ |= 0x00000080;
    }
    /**
     * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
     */
    private void clearUpdatePayment() {  updatePayment_ = null;
      bitField0_ = (bitField0_ & ~0x00000080);
    }

    public static final int PAYMENT_ACK_FIELD_NUMBER = 11;
    private org.flo.paymentchannel.Protos.PaymentAck paymentAck_;
    /**
     * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
     */
    public boolean hasPaymentAck() {
      return ((bitField0_ & 0x00000100) == 0x00000100);
    }
    /**
     * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
     */
    public org.flo.paymentchannel.Protos.PaymentAck getPaymentAck() {
      return paymentAck_ == null ? org.flo.paymentchannel.Protos.PaymentAck.getDefaultInstance() : paymentAck_;
    }
    /**
     * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
     */
    private void setPaymentAck(org.flo.paymentchannel.Protos.PaymentAck value) {
      if (value == null) {
        throw new NullPointerException();
      }
      paymentAck_ = value;
      bitField0_ |= 0x00000100;
      }
    /**
     * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
     */
    private void setPaymentAck(
        org.flo.paymentchannel.Protos.PaymentAck.Builder builderForValue) {
      paymentAck_ = builderForValue.build();
      bitField0_ |= 0x00000100;
    }
    /**
     * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
     */
    private void mergePaymentAck(org.flo.paymentchannel.Protos.PaymentAck value) {
      if (paymentAck_ != null &&
          paymentAck_ != org.flo.paymentchannel.Protos.PaymentAck.getDefaultInstance()) {
        paymentAck_ =
          org.flo.paymentchannel.Protos.PaymentAck.newBuilder(paymentAck_).mergeFrom(value).buildPartial();
      } else {
        paymentAck_ = value;
      }
      bitField0_ |= 0x00000100;
    }
    /**
     * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
     */
    private void clearPaymentAck() {  paymentAck_ = null;
      bitField0_ = (bitField0_ & ~0x00000100);
    }

    public static final int SETTLEMENT_FIELD_NUMBER = 9;
    private org.flo.paymentchannel.Protos.Settlement settlement_;
    /**
     * <code>optional .paymentchannels.Settlement settlement = 9;</code>
     */
    public boolean hasSettlement() {
      return ((bitField0_ & 0x00000200) == 0x00000200);
    }
    /**
     * <code>optional .paymentchannels.Settlement settlement = 9;</code>
     */
    public org.flo.paymentchannel.Protos.Settlement getSettlement() {
      return settlement_ == null ? org.flo.paymentchannel.Protos.Settlement.getDefaultInstance() : settlement_;
    }
    /**
     * <code>optional .paymentchannels.Settlement settlement = 9;</code>
     */
    private void setSettlement(org.flo.paymentchannel.Protos.Settlement value) {
      if (value == null) {
        throw new NullPointerException();
      }
      settlement_ = value;
      bitField0_ |= 0x00000200;
      }
    /**
     * <code>optional .paymentchannels.Settlement settlement = 9;</code>
     */
    private void setSettlement(
        org.flo.paymentchannel.Protos.Settlement.Builder builderForValue) {
      settlement_ = builderForValue.build();
      bitField0_ |= 0x00000200;
    }
    /**
     * <code>optional .paymentchannels.Settlement settlement = 9;</code>
     */
    private void mergeSettlement(org.flo.paymentchannel.Protos.Settlement value) {
      if (settlement_ != null &&
          settlement_ != org.flo.paymentchannel.Protos.Settlement.getDefaultInstance()) {
        settlement_ =
          org.flo.paymentchannel.Protos.Settlement.newBuilder(settlement_).mergeFrom(value).buildPartial();
      } else {
        settlement_ = value;
      }
      bitField0_ |= 0x00000200;
    }
    /**
     * <code>optional .paymentchannels.Settlement settlement = 9;</code>
     */
    private void clearSettlement() {  settlement_ = null;
      bitField0_ = (bitField0_ & ~0x00000200);
    }

    public static final int ERROR_FIELD_NUMBER = 10;
    private org.flo.paymentchannel.Protos.Error error_;
    /**
     * <code>optional .paymentchannels.Error error = 10;</code>
     */
    public boolean hasError() {
      return ((bitField0_ & 0x00000400) == 0x00000400);
    }
    /**
     * <code>optional .paymentchannels.Error error = 10;</code>
     */
    public org.flo.paymentchannel.Protos.Error getError() {
      return error_ == null ? org.flo.paymentchannel.Protos.Error.getDefaultInstance() : error_;
    }
    /**
     * <code>optional .paymentchannels.Error error = 10;</code>
     */
    private void setError(org.flo.paymentchannel.Protos.Error value) {
      if (value == null) {
        throw new NullPointerException();
      }
      error_ = value;
      bitField0_ |= 0x00000400;
      }
    /**
     * <code>optional .paymentchannels.Error error = 10;</code>
     */
    private void setError(
        org.flo.paymentchannel.Protos.Error.Builder builderForValue) {
      error_ = builderForValue.build();
      bitField0_ |= 0x00000400;
    }
    /**
     * <code>optional .paymentchannels.Error error = 10;</code>
     */
    private void mergeError(org.flo.paymentchannel.Protos.Error value) {
      if (error_ != null &&
          error_ != org.flo.paymentchannel.Protos.Error.getDefaultInstance()) {
        error_ =
          org.flo.paymentchannel.Protos.Error.newBuilder(error_).mergeFrom(value).buildPartial();
      } else {
        error_ = value;
      }
      bitField0_ |= 0x00000400;
    }
    /**
     * <code>optional .paymentchannels.Error error = 10;</code>
     */
    private void clearError() {  error_ = null;
      bitField0_ = (bitField0_ & ~0x00000400);
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeEnum(1, type_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getClientVersion());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getServerVersion());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeMessage(4, getInitiate());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeMessage(5, getProvideRefund());
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeMessage(6, getReturnRefund());
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeMessage(7, getProvideContract());
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeMessage(8, getUpdatePayment());
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        output.writeMessage(9, getSettlement());
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        output.writeMessage(10, getError());
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        output.writeMessage(11, getPaymentAck());
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getClientVersion());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getServerVersion());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getInitiate());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getProvideRefund());
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getReturnRefund());
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getProvideContract());
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getUpdatePayment());
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, getSettlement());
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, getError());
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, getPaymentAck());
      }
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static org.flo.paymentchannel.Protos.TwoWayChannelMessage parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.TwoWayChannelMessage parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.TwoWayChannelMessage parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.TwoWayChannelMessage parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.TwoWayChannelMessage parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.TwoWayChannelMessage parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.TwoWayChannelMessage parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.TwoWayChannelMessage parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.TwoWayChannelMessage parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.TwoWayChannelMessage parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.flo.paymentchannel.Protos.TwoWayChannelMessage prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * This message is designed to be either sent raw over the network (e.g. length prefixed) or embedded inside another
     * protocol that is being extended to support micropayments. In this file "primary" typically can be read as "client"
     * and "secondary" as "server".
     * </pre>
     *
     * Protobuf type {@code paymentchannels.TwoWayChannelMessage}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.flo.paymentchannel.Protos.TwoWayChannelMessage, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.TwoWayChannelMessage)
        org.flo.paymentchannel.Protos.TwoWayChannelMessageOrBuilder {
      // Construct using org.flo.paymentchannel.Protos.TwoWayChannelMessage.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * This is required so if a new message type is added in future, old software aborts trying
       * to read the message as early as possible. If the message doesn't parse, the socket should
       * be closed.
       * </pre>
       *
       * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
       */
      public boolean hasType() {
        return instance.hasType();
      }
      /**
       * <pre>
       * This is required so if a new message type is added in future, old software aborts trying
       * to read the message as early as possible. If the message doesn't parse, the socket should
       * be closed.
       * </pre>
       *
       * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
       */
      public org.flo.paymentchannel.Protos.TwoWayChannelMessage.MessageType getType() {
        return instance.getType();
      }
      /**
       * <pre>
       * This is required so if a new message type is added in future, old software aborts trying
       * to read the message as early as possible. If the message doesn't parse, the socket should
       * be closed.
       * </pre>
       *
       * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
       */
      public Builder setType(org.flo.paymentchannel.Protos.TwoWayChannelMessage.MessageType value) {
        copyOnWrite();
        instance.setType(value);
        return this;
      }
      /**
       * <pre>
       * This is required so if a new message type is added in future, old software aborts trying
       * to read the message as early as possible. If the message doesn't parse, the socket should
       * be closed.
       * </pre>
       *
       * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
       */
      public Builder clearType() {
        copyOnWrite();
        instance.clearType();
        return this;
      }

      /**
       * <pre>
       * Now one optional field for each message. Only the field specified by type should be read.
       * </pre>
       *
       * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
       */
      public boolean hasClientVersion() {
        return instance.hasClientVersion();
      }
      /**
       * <pre>
       * Now one optional field for each message. Only the field specified by type should be read.
       * </pre>
       *
       * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
       */
      public org.flo.paymentchannel.Protos.ClientVersion getClientVersion() {
        return instance.getClientVersion();
      }
      /**
       * <pre>
       * Now one optional field for each message. Only the field specified by type should be read.
       * </pre>
       *
       * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
       */
      public Builder setClientVersion(org.flo.paymentchannel.Protos.ClientVersion value) {
        copyOnWrite();
        instance.setClientVersion(value);
        return this;
        }
      /**
       * <pre>
       * Now one optional field for each message. Only the field specified by type should be read.
       * </pre>
       *
       * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
       */
      public Builder setClientVersion(
          org.flo.paymentchannel.Protos.ClientVersion.Builder builderForValue) {
        copyOnWrite();
        instance.setClientVersion(builderForValue);
        return this;
      }
      /**
       * <pre>
       * Now one optional field for each message. Only the field specified by type should be read.
       * </pre>
       *
       * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
       */
      public Builder mergeClientVersion(org.flo.paymentchannel.Protos.ClientVersion value) {
        copyOnWrite();
        instance.mergeClientVersion(value);
        return this;
      }
      /**
       * <pre>
       * Now one optional field for each message. Only the field specified by type should be read.
       * </pre>
       *
       * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
       */
      public Builder clearClientVersion() {  copyOnWrite();
        instance.clearClientVersion();
        return this;
      }

      /**
       * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
       */
      public boolean hasServerVersion() {
        return instance.hasServerVersion();
      }
      /**
       * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
       */
      public org.flo.paymentchannel.Protos.ServerVersion getServerVersion() {
        return instance.getServerVersion();
      }
      /**
       * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
       */
      public Builder setServerVersion(org.flo.paymentchannel.Protos.ServerVersion value) {
        copyOnWrite();
        instance.setServerVersion(value);
        return this;
        }
      /**
       * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
       */
      public Builder setServerVersion(
          org.flo.paymentchannel.Protos.ServerVersion.Builder builderForValue) {
        copyOnWrite();
        instance.setServerVersion(builderForValue);
        return this;
      }
      /**
       * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
       */
      public Builder mergeServerVersion(org.flo.paymentchannel.Protos.ServerVersion value) {
        copyOnWrite();
        instance.mergeServerVersion(value);
        return this;
      }
      /**
       * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
       */
      public Builder clearServerVersion() {  copyOnWrite();
        instance.clearServerVersion();
        return this;
      }

      /**
       * <code>optional .paymentchannels.Initiate initiate = 4;</code>
       */
      public boolean hasInitiate() {
        return instance.hasInitiate();
      }
      /**
       * <code>optional .paymentchannels.Initiate initiate = 4;</code>
       */
      public org.flo.paymentchannel.Protos.Initiate getInitiate() {
        return instance.getInitiate();
      }
      /**
       * <code>optional .paymentchannels.Initiate initiate = 4;</code>
       */
      public Builder setInitiate(org.flo.paymentchannel.Protos.Initiate value) {
        copyOnWrite();
        instance.setInitiate(value);
        return this;
        }
      /**
       * <code>optional .paymentchannels.Initiate initiate = 4;</code>
       */
      public Builder setInitiate(
          org.flo.paymentchannel.Protos.Initiate.Builder builderForValue) {
        copyOnWrite();
        instance.setInitiate(builderForValue);
        return this;
      }
      /**
       * <code>optional .paymentchannels.Initiate initiate = 4;</code>
       */
      public Builder mergeInitiate(org.flo.paymentchannel.Protos.Initiate value) {
        copyOnWrite();
        instance.mergeInitiate(value);
        return this;
      }
      /**
       * <code>optional .paymentchannels.Initiate initiate = 4;</code>
       */
      public Builder clearInitiate() {  copyOnWrite();
        instance.clearInitiate();
        return this;
      }

      /**
       * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
       */
      public boolean hasProvideRefund() {
        return instance.hasProvideRefund();
      }
      /**
       * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
       */
      public org.flo.paymentchannel.Protos.ProvideRefund getProvideRefund() {
        return instance.getProvideRefund();
      }
      /**
       * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
       */
      public Builder setProvideRefund(org.flo.paymentchannel.Protos.ProvideRefund value) {
        copyOnWrite();
        instance.setProvideRefund(value);
        return this;
        }
      /**
       * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
       */
      public Builder setProvideRefund(
          org.flo.paymentchannel.Protos.ProvideRefund.Builder builderForValue) {
        copyOnWrite();
        instance.setProvideRefund(builderForValue);
        return this;
      }
      /**
       * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
       */
      public Builder mergeProvideRefund(org.flo.paymentchannel.Protos.ProvideRefund value) {
        copyOnWrite();
        instance.mergeProvideRefund(value);
        return this;
      }
      /**
       * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
       */
      public Builder clearProvideRefund() {  copyOnWrite();
        instance.clearProvideRefund();
        return this;
      }

      /**
       * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
       */
      public boolean hasReturnRefund() {
        return instance.hasReturnRefund();
      }
      /**
       * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
       */
      public org.flo.paymentchannel.Protos.ReturnRefund getReturnRefund() {
        return instance.getReturnRefund();
      }
      /**
       * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
       */
      public Builder setReturnRefund(org.flo.paymentchannel.Protos.ReturnRefund value) {
        copyOnWrite();
        instance.setReturnRefund(value);
        return this;
        }
      /**
       * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
       */
      public Builder setReturnRefund(
          org.flo.paymentchannel.Protos.ReturnRefund.Builder builderForValue) {
        copyOnWrite();
        instance.setReturnRefund(builderForValue);
        return this;
      }
      /**
       * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
       */
      public Builder mergeReturnRefund(org.flo.paymentchannel.Protos.ReturnRefund value) {
        copyOnWrite();
        instance.mergeReturnRefund(value);
        return this;
      }
      /**
       * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
       */
      public Builder clearReturnRefund() {  copyOnWrite();
        instance.clearReturnRefund();
        return this;
      }

      /**
       * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
       */
      public boolean hasProvideContract() {
        return instance.hasProvideContract();
      }
      /**
       * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
       */
      public org.flo.paymentchannel.Protos.ProvideContract getProvideContract() {
        return instance.getProvideContract();
      }
      /**
       * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
       */
      public Builder setProvideContract(org.flo.paymentchannel.Protos.ProvideContract value) {
        copyOnWrite();
        instance.setProvideContract(value);
        return this;
        }
      /**
       * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
       */
      public Builder setProvideContract(
          org.flo.paymentchannel.Protos.ProvideContract.Builder builderForValue) {
        copyOnWrite();
        instance.setProvideContract(builderForValue);
        return this;
      }
      /**
       * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
       */
      public Builder mergeProvideContract(org.flo.paymentchannel.Protos.ProvideContract value) {
        copyOnWrite();
        instance.mergeProvideContract(value);
        return this;
      }
      /**
       * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
       */
      public Builder clearProvideContract() {  copyOnWrite();
        instance.clearProvideContract();
        return this;
      }

      /**
       * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
       */
      public boolean hasUpdatePayment() {
        return instance.hasUpdatePayment();
      }
      /**
       * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
       */
      public org.flo.paymentchannel.Protos.UpdatePayment getUpdatePayment() {
        return instance.getUpdatePayment();
      }
      /**
       * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
       */
      public Builder setUpdatePayment(org.flo.paymentchannel.Protos.UpdatePayment value) {
        copyOnWrite();
        instance.setUpdatePayment(value);
        return this;
        }
      /**
       * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
       */
      public Builder setUpdatePayment(
          org.flo.paymentchannel.Protos.UpdatePayment.Builder builderForValue) {
        copyOnWrite();
        instance.setUpdatePayment(builderForValue);
        return this;
      }
      /**
       * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
       */
      public Builder mergeUpdatePayment(org.flo.paymentchannel.Protos.UpdatePayment value) {
        copyOnWrite();
        instance.mergeUpdatePayment(value);
        return this;
      }
      /**
       * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
       */
      public Builder clearUpdatePayment() {  copyOnWrite();
        instance.clearUpdatePayment();
        return this;
      }

      /**
       * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
       */
      public boolean hasPaymentAck() {
        return instance.hasPaymentAck();
      }
      /**
       * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
       */
      public org.flo.paymentchannel.Protos.PaymentAck getPaymentAck() {
        return instance.getPaymentAck();
      }
      /**
       * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
       */
      public Builder setPaymentAck(org.flo.paymentchannel.Protos.PaymentAck value) {
        copyOnWrite();
        instance.setPaymentAck(value);
        return this;
        }
      /**
       * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
       */
      public Builder setPaymentAck(
          org.flo.paymentchannel.Protos.PaymentAck.Builder builderForValue) {
        copyOnWrite();
        instance.setPaymentAck(builderForValue);
        return this;
      }
      /**
       * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
       */
      public Builder mergePaymentAck(org.flo.paymentchannel.Protos.PaymentAck value) {
        copyOnWrite();
        instance.mergePaymentAck(value);
        return this;
      }
      /**
       * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
       */
      public Builder clearPaymentAck() {  copyOnWrite();
        instance.clearPaymentAck();
        return this;
      }

      /**
       * <code>optional .paymentchannels.Settlement settlement = 9;</code>
       */
      public boolean hasSettlement() {
        return instance.hasSettlement();
      }
      /**
       * <code>optional .paymentchannels.Settlement settlement = 9;</code>
       */
      public org.flo.paymentchannel.Protos.Settlement getSettlement() {
        return instance.getSettlement();
      }
      /**
       * <code>optional .paymentchannels.Settlement settlement = 9;</code>
       */
      public Builder setSettlement(org.flo.paymentchannel.Protos.Settlement value) {
        copyOnWrite();
        instance.setSettlement(value);
        return this;
        }
      /**
       * <code>optional .paymentchannels.Settlement settlement = 9;</code>
       */
      public Builder setSettlement(
          org.flo.paymentchannel.Protos.Settlement.Builder builderForValue) {
        copyOnWrite();
        instance.setSettlement(builderForValue);
        return this;
      }
      /**
       * <code>optional .paymentchannels.Settlement settlement = 9;</code>
       */
      public Builder mergeSettlement(org.flo.paymentchannel.Protos.Settlement value) {
        copyOnWrite();
        instance.mergeSettlement(value);
        return this;
      }
      /**
       * <code>optional .paymentchannels.Settlement settlement = 9;</code>
       */
      public Builder clearSettlement() {  copyOnWrite();
        instance.clearSettlement();
        return this;
      }

      /**
       * <code>optional .paymentchannels.Error error = 10;</code>
       */
      public boolean hasError() {
        return instance.hasError();
      }
      /**
       * <code>optional .paymentchannels.Error error = 10;</code>
       */
      public org.flo.paymentchannel.Protos.Error getError() {
        return instance.getError();
      }
      /**
       * <code>optional .paymentchannels.Error error = 10;</code>
       */
      public Builder setError(org.flo.paymentchannel.Protos.Error value) {
        copyOnWrite();
        instance.setError(value);
        return this;
        }
      /**
       * <code>optional .paymentchannels.Error error = 10;</code>
       */
      public Builder setError(
          org.flo.paymentchannel.Protos.Error.Builder builderForValue) {
        copyOnWrite();
        instance.setError(builderForValue);
        return this;
      }
      /**
       * <code>optional .paymentchannels.Error error = 10;</code>
       */
      public Builder mergeError(org.flo.paymentchannel.Protos.Error value) {
        copyOnWrite();
        instance.mergeError(value);
        return this;
      }
      /**
       * <code>optional .paymentchannels.Error error = 10;</code>
       */
      public Builder clearError() {  copyOnWrite();
        instance.clearError();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.TwoWayChannelMessage)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.flo.paymentchannel.Protos.TwoWayChannelMessage();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (!hasType()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (hasClientVersion()) {
            if (!getClientVersion().isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (hasServerVersion()) {
            if (!getServerVersion().isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (hasInitiate()) {
            if (!getInitiate().isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (hasProvideRefund()) {
            if (!getProvideRefund().isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (hasReturnRefund()) {
            if (!getReturnRefund().isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (hasProvideContract()) {
            if (!getProvideContract().isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (hasUpdatePayment()) {
            if (!getUpdatePayment().isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (hasSettlement()) {
            if (!getSettlement().isInitialized()) {
              if (shouldMemoize) {
                memoizedIsInitialized = 0;
              }
              return null;
            }
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          org.flo.paymentchannel.Protos.TwoWayChannelMessage other = (org.flo.paymentchannel.Protos.TwoWayChannelMessage) arg1;
          type_ = visitor.visitInt(hasType(), type_,
              other.hasType(), other.type_);
          clientVersion_ = visitor.visitMessage(clientVersion_, other.clientVersion_);
          serverVersion_ = visitor.visitMessage(serverVersion_, other.serverVersion_);
          initiate_ = visitor.visitMessage(initiate_, other.initiate_);
          provideRefund_ = visitor.visitMessage(provideRefund_, other.provideRefund_);
          returnRefund_ = visitor.visitMessage(returnRefund_, other.returnRefund_);
          provideContract_ = visitor.visitMessage(provideContract_, other.provideContract_);
          updatePayment_ = visitor.visitMessage(updatePayment_, other.updatePayment_);
          paymentAck_ = visitor.visitMessage(paymentAck_, other.paymentAck_);
          settlement_ = visitor.visitMessage(settlement_, other.settlement_);
          error_ = visitor.visitMessage(error_, other.error_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(tag, input)) {
                    done = true;
                  }
                  break;
                }
                case 8: {
                  int rawValue = input.readEnum();
                  org.flo.paymentchannel.Protos.TwoWayChannelMessage.MessageType value = org.flo.paymentchannel.Protos.TwoWayChannelMessage.MessageType.forNumber(rawValue);
                  if (value == null) {
                    super.mergeVarintField(1, rawValue);
                  } else {
                    bitField0_ |= 0x00000001;
                    type_ = rawValue;
                  }
                  break;
                }
                case 18: {
                  org.flo.paymentchannel.Protos.ClientVersion.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000002) == 0x00000002)) {
                    subBuilder = clientVersion_.toBuilder();
                  }
                  clientVersion_ = input.readMessage(org.flo.paymentchannel.Protos.ClientVersion.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(clientVersion_);
                    clientVersion_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000002;
                  break;
                }
                case 26: {
                  org.flo.paymentchannel.Protos.ServerVersion.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000004) == 0x00000004)) {
                    subBuilder = serverVersion_.toBuilder();
                  }
                  serverVersion_ = input.readMessage(org.flo.paymentchannel.Protos.ServerVersion.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(serverVersion_);
                    serverVersion_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000004;
                  break;
                }
                case 34: {
                  org.flo.paymentchannel.Protos.Initiate.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000008) == 0x00000008)) {
                    subBuilder = initiate_.toBuilder();
                  }
                  initiate_ = input.readMessage(org.flo.paymentchannel.Protos.Initiate.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(initiate_);
                    initiate_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000008;
                  break;
                }
                case 42: {
                  org.flo.paymentchannel.Protos.ProvideRefund.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000010) == 0x00000010)) {
                    subBuilder = provideRefund_.toBuilder();
                  }
                  provideRefund_ = input.readMessage(org.flo.paymentchannel.Protos.ProvideRefund.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(provideRefund_);
                    provideRefund_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000010;
                  break;
                }
                case 50: {
                  org.flo.paymentchannel.Protos.ReturnRefund.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000020) == 0x00000020)) {
                    subBuilder = returnRefund_.toBuilder();
                  }
                  returnRefund_ = input.readMessage(org.flo.paymentchannel.Protos.ReturnRefund.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(returnRefund_);
                    returnRefund_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000020;
                  break;
                }
                case 58: {
                  org.flo.paymentchannel.Protos.ProvideContract.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000040) == 0x00000040)) {
                    subBuilder = provideContract_.toBuilder();
                  }
                  provideContract_ = input.readMessage(org.flo.paymentchannel.Protos.ProvideContract.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(provideContract_);
                    provideContract_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000040;
                  break;
                }
                case 66: {
                  org.flo.paymentchannel.Protos.UpdatePayment.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000080) == 0x00000080)) {
                    subBuilder = updatePayment_.toBuilder();
                  }
                  updatePayment_ = input.readMessage(org.flo.paymentchannel.Protos.UpdatePayment.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(updatePayment_);
                    updatePayment_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000080;
                  break;
                }
                case 74: {
                  org.flo.paymentchannel.Protos.Settlement.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000200) == 0x00000200)) {
                    subBuilder = settlement_.toBuilder();
                  }
                  settlement_ = input.readMessage(org.flo.paymentchannel.Protos.Settlement.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(settlement_);
                    settlement_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000200;
                  break;
                }
                case 82: {
                  org.flo.paymentchannel.Protos.Error.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000400) == 0x00000400)) {
                    subBuilder = error_.toBuilder();
                  }
                  error_ = input.readMessage(org.flo.paymentchannel.Protos.Error.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(error_);
                    error_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000400;
                  break;
                }
                case 90: {
                  org.flo.paymentchannel.Protos.PaymentAck.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000100) == 0x00000100)) {
                    subBuilder = paymentAck_.toBuilder();
                  }
                  paymentAck_ = input.readMessage(org.flo.paymentchannel.Protos.PaymentAck.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(paymentAck_);
                    paymentAck_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000100;
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (org.flo.paymentchannel.Protos.TwoWayChannelMessage.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.TwoWayChannelMessage)
    private static final org.flo.paymentchannel.Protos.TwoWayChannelMessage DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new TwoWayChannelMessage();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static org.flo.paymentchannel.Protos.TwoWayChannelMessage getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TwoWayChannelMessage> PARSER;

    public static com.google.protobuf.Parser<TwoWayChannelMessage> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ClientVersionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.ClientVersion)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>required int32 major = 1;</code>
     */
    boolean hasMajor();
    /**
     * <code>required int32 major = 1;</code>
     */
    int getMajor();

    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     */
    boolean hasMinor();
    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     */
    int getMinor();

    /**
     * <pre>
     * The hash of the multisig contract of a previous channel. This indicates that the primary
     * wishes to reopen the given channel. If the server is willing to reopen it, it simply
     * responds with a SERVER_VERSION and then immediately sends a CHANNEL_OPEN, it otherwise
     * follows SERVER_VERSION with an Initiate representing a new channel
     * </pre>
     *
     * <code>optional bytes previous_channel_contract_hash = 3;</code>
     */
    boolean hasPreviousChannelContractHash();
    /**
     * <pre>
     * The hash of the multisig contract of a previous channel. This indicates that the primary
     * wishes to reopen the given channel. If the server is willing to reopen it, it simply
     * responds with a SERVER_VERSION and then immediately sends a CHANNEL_OPEN, it otherwise
     * follows SERVER_VERSION with an Initiate representing a new channel
     * </pre>
     *
     * <code>optional bytes previous_channel_contract_hash = 3;</code>
     */
    com.google.protobuf.ByteString getPreviousChannelContractHash();

    /**
     * <pre>
     * How many seconds should the channel be open, only used when a new channel is created.
     * Defaults to 24 h minus 60 seconds, 24*60*60 - 60
     * </pre>
     *
     * <code>optional uint64 time_window_secs = 4 [default = 86340];</code>
     */
    boolean hasTimeWindowSecs();
    /**
     * <pre>
     * How many seconds should the channel be open, only used when a new channel is created.
     * Defaults to 24 h minus 60 seconds, 24*60*60 - 60
     * </pre>
     *
     * <code>optional uint64 time_window_secs = 4 [default = 86340];</code>
     */
    long getTimeWindowSecs();
  }
  /**
   * <pre>
   * Sent by primary to secondary on opening the connection. If anything is received before this is
   * sent, the socket is closed.
   * </pre>
   *
   * Protobuf type {@code paymentchannels.ClientVersion}
   */
  public  static final class ClientVersion extends
      com.google.protobuf.GeneratedMessageLite<
          ClientVersion, ClientVersion.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.ClientVersion)
      ClientVersionOrBuilder {
    private ClientVersion() {
      previousChannelContractHash_ = com.google.protobuf.ByteString.EMPTY;
      timeWindowSecs_ = 86340L;
    }
    private int bitField0_;
    public static final int MAJOR_FIELD_NUMBER = 1;
    private int major_;
    /**
     * <code>required int32 major = 1;</code>
     */
    public boolean hasMajor() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>required int32 major = 1;</code>
     */
    public int getMajor() {
      return major_;
    }
    /**
     * <code>required int32 major = 1;</code>
     */
    private void setMajor(int value) {
      bitField0_ |= 0x00000001;
      major_ = value;
    }
    /**
     * <code>required int32 major = 1;</code>
     */
    private void clearMajor() {
      bitField0_ = (bitField0_ & ~0x00000001);
      major_ = 0;
    }

    public static final int MINOR_FIELD_NUMBER = 2;
    private int minor_;
    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     */
    public boolean hasMinor() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     */
    public int getMinor() {
      return minor_;
    }
    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     */
    private void setMinor(int value) {
      bitField0_ |= 0x00000002;
      minor_ = value;
    }
    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     */
    private void clearMinor() {
      bitField0_ = (bitField0_ & ~0x00000002);
      minor_ = 0;
    }

    public static final int PREVIOUS_CHANNEL_CONTRACT_HASH_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString previousChannelContractHash_;
    /**
     * <pre>
     * The hash of the multisig contract of a previous channel. This indicates that the primary
     * wishes to reopen the given channel. If the server is willing to reopen it, it simply
     * responds with a SERVER_VERSION and then immediately sends a CHANNEL_OPEN, it otherwise
     * follows SERVER_VERSION with an Initiate representing a new channel
     * </pre>
     *
     * <code>optional bytes previous_channel_contract_hash = 3;</code>
     */
    public boolean hasPreviousChannelContractHash() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * The hash of the multisig contract of a previous channel. This indicates that the primary
     * wishes to reopen the given channel. If the server is willing to reopen it, it simply
     * responds with a SERVER_VERSION and then immediately sends a CHANNEL_OPEN, it otherwise
     * follows SERVER_VERSION with an Initiate representing a new channel
     * </pre>
     *
     * <code>optional bytes previous_channel_contract_hash = 3;</code>
     */
    public com.google.protobuf.ByteString getPreviousChannelContractHash() {
      return previousChannelContractHash_;
    }
    /**
     * <pre>
     * The hash of the multisig contract of a previous channel. This indicates that the primary
     * wishes to reopen the given channel. If the server is willing to reopen it, it simply
     * responds with a SERVER_VERSION and then immediately sends a CHANNEL_OPEN, it otherwise
     * follows SERVER_VERSION with an Initiate representing a new channel
     * </pre>
     *
     * <code>optional bytes previous_channel_contract_hash = 3;</code>
     */
    private void setPreviousChannelContractHash(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
      previousChannelContractHash_ = value;
    }
    /**
     * <pre>
     * The hash of the multisig contract of a previous channel. This indicates that the primary
     * wishes to reopen the given channel. If the server is willing to reopen it, it simply
     * responds with a SERVER_VERSION and then immediately sends a CHANNEL_OPEN, it otherwise
     * follows SERVER_VERSION with an Initiate representing a new channel
     * </pre>
     *
     * <code>optional bytes previous_channel_contract_hash = 3;</code>
     */
    private void clearPreviousChannelContractHash() {
      bitField0_ = (bitField0_ & ~0x00000004);
      previousChannelContractHash_ = getDefaultInstance().getPreviousChannelContractHash();
    }

    public static final int TIME_WINDOW_SECS_FIELD_NUMBER = 4;
    private long timeWindowSecs_;
    /**
     * <pre>
     * How many seconds should the channel be open, only used when a new channel is created.
     * Defaults to 24 h minus 60 seconds, 24*60*60 - 60
     * </pre>
     *
     * <code>optional uint64 time_window_secs = 4 [default = 86340];</code>
     */
    public boolean hasTimeWindowSecs() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * How many seconds should the channel be open, only used when a new channel is created.
     * Defaults to 24 h minus 60 seconds, 24*60*60 - 60
     * </pre>
     *
     * <code>optional uint64 time_window_secs = 4 [default = 86340];</code>
     */
    public long getTimeWindowSecs() {
      return timeWindowSecs_;
    }
    /**
     * <pre>
     * How many seconds should the channel be open, only used when a new channel is created.
     * Defaults to 24 h minus 60 seconds, 24*60*60 - 60
     * </pre>
     *
     * <code>optional uint64 time_window_secs = 4 [default = 86340];</code>
     */
    private void setTimeWindowSecs(long value) {
      bitField0_ |= 0x00000008;
      timeWindowSecs_ = value;
    }
    /**
     * <pre>
     * How many seconds should the channel be open, only used when a new channel is created.
     * Defaults to 24 h minus 60 seconds, 24*60*60 - 60
     * </pre>
     *
     * <code>optional uint64 time_window_secs = 4 [default = 86340];</code>
     */
    private void clearTimeWindowSecs() {
      bitField0_ = (bitField0_ & ~0x00000008);
      timeWindowSecs_ = 86340L;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt32(1, major_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt32(2, minor_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBytes(3, previousChannelContractHash_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeUInt64(4, timeWindowSecs_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, major_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, minor_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, previousChannelContractHash_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(4, timeWindowSecs_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static org.flo.paymentchannel.Protos.ClientVersion parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.ClientVersion parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.ClientVersion parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.ClientVersion parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.ClientVersion parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.ClientVersion parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.ClientVersion parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.ClientVersion parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.ClientVersion parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.ClientVersion parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.flo.paymentchannel.Protos.ClientVersion prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * Sent by primary to secondary on opening the connection. If anything is received before this is
     * sent, the socket is closed.
     * </pre>
     *
     * Protobuf type {@code paymentchannels.ClientVersion}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.flo.paymentchannel.Protos.ClientVersion, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.ClientVersion)
        org.flo.paymentchannel.Protos.ClientVersionOrBuilder {
      // Construct using org.flo.paymentchannel.Protos.ClientVersion.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>required int32 major = 1;</code>
       */
      public boolean hasMajor() {
        return instance.hasMajor();
      }
      /**
       * <code>required int32 major = 1;</code>
       */
      public int getMajor() {
        return instance.getMajor();
      }
      /**
       * <code>required int32 major = 1;</code>
       */
      public Builder setMajor(int value) {
        copyOnWrite();
        instance.setMajor(value);
        return this;
      }
      /**
       * <code>required int32 major = 1;</code>
       */
      public Builder clearMajor() {
        copyOnWrite();
        instance.clearMajor();
        return this;
      }

      /**
       * <code>optional int32 minor = 2 [default = 0];</code>
       */
      public boolean hasMinor() {
        return instance.hasMinor();
      }
      /**
       * <code>optional int32 minor = 2 [default = 0];</code>
       */
      public int getMinor() {
        return instance.getMinor();
      }
      /**
       * <code>optional int32 minor = 2 [default = 0];</code>
       */
      public Builder setMinor(int value) {
        copyOnWrite();
        instance.setMinor(value);
        return this;
      }
      /**
       * <code>optional int32 minor = 2 [default = 0];</code>
       */
      public Builder clearMinor() {
        copyOnWrite();
        instance.clearMinor();
        return this;
      }

      /**
       * <pre>
       * The hash of the multisig contract of a previous channel. This indicates that the primary
       * wishes to reopen the given channel. If the server is willing to reopen it, it simply
       * responds with a SERVER_VERSION and then immediately sends a CHANNEL_OPEN, it otherwise
       * follows SERVER_VERSION with an Initiate representing a new channel
       * </pre>
       *
       * <code>optional bytes previous_channel_contract_hash = 3;</code>
       */
      public boolean hasPreviousChannelContractHash() {
        return instance.hasPreviousChannelContractHash();
      }
      /**
       * <pre>
       * The hash of the multisig contract of a previous channel. This indicates that the primary
       * wishes to reopen the given channel. If the server is willing to reopen it, it simply
       * responds with a SERVER_VERSION and then immediately sends a CHANNEL_OPEN, it otherwise
       * follows SERVER_VERSION with an Initiate representing a new channel
       * </pre>
       *
       * <code>optional bytes previous_channel_contract_hash = 3;</code>
       */
      public com.google.protobuf.ByteString getPreviousChannelContractHash() {
        return instance.getPreviousChannelContractHash();
      }
      /**
       * <pre>
       * The hash of the multisig contract of a previous channel. This indicates that the primary
       * wishes to reopen the given channel. If the server is willing to reopen it, it simply
       * responds with a SERVER_VERSION and then immediately sends a CHANNEL_OPEN, it otherwise
       * follows SERVER_VERSION with an Initiate representing a new channel
       * </pre>
       *
       * <code>optional bytes previous_channel_contract_hash = 3;</code>
       */
      public Builder setPreviousChannelContractHash(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPreviousChannelContractHash(value);
        return this;
      }
      /**
       * <pre>
       * The hash of the multisig contract of a previous channel. This indicates that the primary
       * wishes to reopen the given channel. If the server is willing to reopen it, it simply
       * responds with a SERVER_VERSION and then immediately sends a CHANNEL_OPEN, it otherwise
       * follows SERVER_VERSION with an Initiate representing a new channel
       * </pre>
       *
       * <code>optional bytes previous_channel_contract_hash = 3;</code>
       */
      public Builder clearPreviousChannelContractHash() {
        copyOnWrite();
        instance.clearPreviousChannelContractHash();
        return this;
      }

      /**
       * <pre>
       * How many seconds should the channel be open, only used when a new channel is created.
       * Defaults to 24 h minus 60 seconds, 24*60*60 - 60
       * </pre>
       *
       * <code>optional uint64 time_window_secs = 4 [default = 86340];</code>
       */
      public boolean hasTimeWindowSecs() {
        return instance.hasTimeWindowSecs();
      }
      /**
       * <pre>
       * How many seconds should the channel be open, only used when a new channel is created.
       * Defaults to 24 h minus 60 seconds, 24*60*60 - 60
       * </pre>
       *
       * <code>optional uint64 time_window_secs = 4 [default = 86340];</code>
       */
      public long getTimeWindowSecs() {
        return instance.getTimeWindowSecs();
      }
      /**
       * <pre>
       * How many seconds should the channel be open, only used when a new channel is created.
       * Defaults to 24 h minus 60 seconds, 24*60*60 - 60
       * </pre>
       *
       * <code>optional uint64 time_window_secs = 4 [default = 86340];</code>
       */
      public Builder setTimeWindowSecs(long value) {
        copyOnWrite();
        instance.setTimeWindowSecs(value);
        return this;
      }
      /**
       * <pre>
       * How many seconds should the channel be open, only used when a new channel is created.
       * Defaults to 24 h minus 60 seconds, 24*60*60 - 60
       * </pre>
       *
       * <code>optional uint64 time_window_secs = 4 [default = 86340];</code>
       */
      public Builder clearTimeWindowSecs() {
        copyOnWrite();
        instance.clearTimeWindowSecs();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.ClientVersion)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.flo.paymentchannel.Protos.ClientVersion();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (!hasMajor()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          org.flo.paymentchannel.Protos.ClientVersion other = (org.flo.paymentchannel.Protos.ClientVersion) arg1;
          major_ = visitor.visitInt(
              hasMajor(), major_,
              other.hasMajor(), other.major_);
          minor_ = visitor.visitInt(
              hasMinor(), minor_,
              other.hasMinor(), other.minor_);
          previousChannelContractHash_ = visitor.visitByteString(
              hasPreviousChannelContractHash(), previousChannelContractHash_,
              other.hasPreviousChannelContractHash(), other.previousChannelContractHash_);
          timeWindowSecs_ = visitor.visitLong(
              hasTimeWindowSecs(), timeWindowSecs_,
              other.hasTimeWindowSecs(), other.timeWindowSecs_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(tag, input)) {
                    done = true;
                  }
                  break;
                }
                case 8: {
                  bitField0_ |= 0x00000001;
                  major_ = input.readInt32();
                  break;
                }
                case 16: {
                  bitField0_ |= 0x00000002;
                  minor_ = input.readInt32();
                  break;
                }
                case 26: {
                  bitField0_ |= 0x00000004;
                  previousChannelContractHash_ = input.readBytes();
                  break;
                }
                case 32: {
                  bitField0_ |= 0x00000008;
                  timeWindowSecs_ = input.readUInt64();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (org.flo.paymentchannel.Protos.ClientVersion.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.ClientVersion)
    private static final org.flo.paymentchannel.Protos.ClientVersion DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ClientVersion();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static org.flo.paymentchannel.Protos.ClientVersion getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ClientVersion> PARSER;

    public static com.google.protobuf.Parser<ClientVersion> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ServerVersionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.ServerVersion)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>required int32 major = 1;</code>
     */
    boolean hasMajor();
    /**
     * <code>required int32 major = 1;</code>
     */
    int getMajor();

    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     */
    boolean hasMinor();
    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     */
    int getMinor();
  }
  /**
   * <pre>
   * Send by secondary to primary upon receiving the ClientVersion message. If it is willing to
   * speak the given major version, it sends back the same major version and the minor version it
   * speaks. If it is not, it may send back a lower major version representing the highest version
   * it is willing to speak, or sends a NO_ACCEPTABLE_VERSION Error. If the secondary sends back a
   * lower major version, the secondary should either expect to continue with that version, or
   * should immediately close the connection with a NO_ACCEPTABLE_VERSION Error. Backwards
   * incompatible changes to the protocol bump the major version. Extensions bump the minor version
   * </pre>
   *
   * Protobuf type {@code paymentchannels.ServerVersion}
   */
  public  static final class ServerVersion extends
      com.google.protobuf.GeneratedMessageLite<
          ServerVersion, ServerVersion.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.ServerVersion)
      ServerVersionOrBuilder {
    private ServerVersion() {
    }
    private int bitField0_;
    public static final int MAJOR_FIELD_NUMBER = 1;
    private int major_;
    /**
     * <code>required int32 major = 1;</code>
     */
    public boolean hasMajor() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>required int32 major = 1;</code>
     */
    public int getMajor() {
      return major_;
    }
    /**
     * <code>required int32 major = 1;</code>
     */
    private void setMajor(int value) {
      bitField0_ |= 0x00000001;
      major_ = value;
    }
    /**
     * <code>required int32 major = 1;</code>
     */
    private void clearMajor() {
      bitField0_ = (bitField0_ & ~0x00000001);
      major_ = 0;
    }

    public static final int MINOR_FIELD_NUMBER = 2;
    private int minor_;
    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     */
    public boolean hasMinor() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     */
    public int getMinor() {
      return minor_;
    }
    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     */
    private void setMinor(int value) {
      bitField0_ |= 0x00000002;
      minor_ = value;
    }
    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     */
    private void clearMinor() {
      bitField0_ = (bitField0_ & ~0x00000002);
      minor_ = 0;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt32(1, major_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt32(2, minor_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, major_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, minor_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static org.flo.paymentchannel.Protos.ServerVersion parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.ServerVersion parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.ServerVersion parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.ServerVersion parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.ServerVersion parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.ServerVersion parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.ServerVersion parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.ServerVersion parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.ServerVersion parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.ServerVersion parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.flo.paymentchannel.Protos.ServerVersion prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * Send by secondary to primary upon receiving the ClientVersion message. If it is willing to
     * speak the given major version, it sends back the same major version and the minor version it
     * speaks. If it is not, it may send back a lower major version representing the highest version
     * it is willing to speak, or sends a NO_ACCEPTABLE_VERSION Error. If the secondary sends back a
     * lower major version, the secondary should either expect to continue with that version, or
     * should immediately close the connection with a NO_ACCEPTABLE_VERSION Error. Backwards
     * incompatible changes to the protocol bump the major version. Extensions bump the minor version
     * </pre>
     *
     * Protobuf type {@code paymentchannels.ServerVersion}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.flo.paymentchannel.Protos.ServerVersion, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.ServerVersion)
        org.flo.paymentchannel.Protos.ServerVersionOrBuilder {
      // Construct using org.flo.paymentchannel.Protos.ServerVersion.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>required int32 major = 1;</code>
       */
      public boolean hasMajor() {
        return instance.hasMajor();
      }
      /**
       * <code>required int32 major = 1;</code>
       */
      public int getMajor() {
        return instance.getMajor();
      }
      /**
       * <code>required int32 major = 1;</code>
       */
      public Builder setMajor(int value) {
        copyOnWrite();
        instance.setMajor(value);
        return this;
      }
      /**
       * <code>required int32 major = 1;</code>
       */
      public Builder clearMajor() {
        copyOnWrite();
        instance.clearMajor();
        return this;
      }

      /**
       * <code>optional int32 minor = 2 [default = 0];</code>
       */
      public boolean hasMinor() {
        return instance.hasMinor();
      }
      /**
       * <code>optional int32 minor = 2 [default = 0];</code>
       */
      public int getMinor() {
        return instance.getMinor();
      }
      /**
       * <code>optional int32 minor = 2 [default = 0];</code>
       */
      public Builder setMinor(int value) {
        copyOnWrite();
        instance.setMinor(value);
        return this;
      }
      /**
       * <code>optional int32 minor = 2 [default = 0];</code>
       */
      public Builder clearMinor() {
        copyOnWrite();
        instance.clearMinor();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.ServerVersion)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.flo.paymentchannel.Protos.ServerVersion();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (!hasMajor()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          org.flo.paymentchannel.Protos.ServerVersion other = (org.flo.paymentchannel.Protos.ServerVersion) arg1;
          major_ = visitor.visitInt(
              hasMajor(), major_,
              other.hasMajor(), other.major_);
          minor_ = visitor.visitInt(
              hasMinor(), minor_,
              other.hasMinor(), other.minor_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(tag, input)) {
                    done = true;
                  }
                  break;
                }
                case 8: {
                  bitField0_ |= 0x00000001;
                  major_ = input.readInt32();
                  break;
                }
                case 16: {
                  bitField0_ |= 0x00000002;
                  minor_ = input.readInt32();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (org.flo.paymentchannel.Protos.ServerVersion.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.ServerVersion)
    private static final org.flo.paymentchannel.Protos.ServerVersion DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ServerVersion();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static org.flo.paymentchannel.Protos.ServerVersion getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ServerVersion> PARSER;

    public static com.google.protobuf.Parser<ServerVersion> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface InitiateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.Initiate)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted. It is used only in the creation of the multisig contract, as outputs are
     * created entirely by the secondary
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     */
    boolean hasMultisigKey();
    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted. It is used only in the creation of the multisig contract, as outputs are
     * created entirely by the secondary
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     */
    com.google.protobuf.ByteString getMultisigKey();

    /**
     * <pre>
     * Once a channel is exhausted a new one must be set up. So secondary indicates the minimum
     * size it's willing to accept here. This can be lower to trade off resources against
     * security but shouldn't be so low the transactions get rejected by the network as spam.
     * Zero isn't a sensible value to have here, so we make the field required.
     * </pre>
     *
     * <code>required uint64 min_accepted_channel_size = 2;</code>
     */
    boolean hasMinAcceptedChannelSize();
    /**
     * <pre>
     * Once a channel is exhausted a new one must be set up. So secondary indicates the minimum
     * size it's willing to accept here. This can be lower to trade off resources against
     * security but shouldn't be so low the transactions get rejected by the network as spam.
     * Zero isn't a sensible value to have here, so we make the field required.
     * </pre>
     *
     * <code>required uint64 min_accepted_channel_size = 2;</code>
     */
    long getMinAcceptedChannelSize();

    /**
     * <pre>
     * Rough UNIX time for when the channel expires. This is determined by the block header
     * timestamps which can be very inaccurate when miners use the obsolete RollNTime hack.
     * Channels could also be specified in terms of block heights but then how do you know the
     * current chain height if you don't have internet access? Trust the server? Probably opens up
     * attack vectors. We can assume the client has an independent clock, however. If the client
     * considers this value too far off (eg more than a day), it may send an ERROR and close the
     * channel.
     * </pre>
     *
     * <code>required uint64 expire_time_secs = 3;</code>
     */
    boolean hasExpireTimeSecs();
    /**
     * <pre>
     * Rough UNIX time for when the channel expires. This is determined by the block header
     * timestamps which can be very inaccurate when miners use the obsolete RollNTime hack.
     * Channels could also be specified in terms of block heights but then how do you know the
     * current chain height if you don't have internet access? Trust the server? Probably opens up
     * attack vectors. We can assume the client has an independent clock, however. If the client
     * considers this value too far off (eg more than a day), it may send an ERROR and close the
     * channel.
     * </pre>
     *
     * <code>required uint64 expire_time_secs = 3;</code>
     */
    long getExpireTimeSecs();

    /**
     * <pre>
     * The amount of money the server requires for the initial payment. The act of opening a channel
     * always transfers some quantity of money to the server: it's impossible to have a channel with
     * zero value transferred. This rule ensures that you can't get a channel that can't be settled
     * due to having paid under the dust limit. Because the dust limit will float in future, the
     * server tells the client what it thinks it is, and the client is supposed to sanity check this
     * value.
     * </pre>
     *
     * <code>required uint64 min_payment = 4;</code>
     */
    boolean hasMinPayment();
    /**
     * <pre>
     * The amount of money the server requires for the initial payment. The act of opening a channel
     * always transfers some quantity of money to the server: it's impossible to have a channel with
     * zero value transferred. This rule ensures that you can't get a channel that can't be settled
     * due to having paid under the dust limit. Because the dust limit will float in future, the
     * server tells the client what it thinks it is, and the client is supposed to sanity check this
     * value.
     * </pre>
     *
     * <code>required uint64 min_payment = 4;</code>
     */
    long getMinPayment();
  }
  /**
   * <pre>
   * Sent from server to client once version nego is done.
   * </pre>
   *
   * Protobuf type {@code paymentchannels.Initiate}
   */
  public  static final class Initiate extends
      com.google.protobuf.GeneratedMessageLite<
          Initiate, Initiate.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.Initiate)
      InitiateOrBuilder {
    private Initiate() {
      multisigKey_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int MULTISIG_KEY_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString multisigKey_;
    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted. It is used only in the creation of the multisig contract, as outputs are
     * created entirely by the secondary
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     */
    public boolean hasMultisigKey() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted. It is used only in the creation of the multisig contract, as outputs are
     * created entirely by the secondary
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     */
    public com.google.protobuf.ByteString getMultisigKey() {
      return multisigKey_;
    }
    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted. It is used only in the creation of the multisig contract, as outputs are
     * created entirely by the secondary
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     */
    private void setMultisigKey(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
      multisigKey_ = value;
    }
    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted. It is used only in the creation of the multisig contract, as outputs are
     * created entirely by the secondary
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     */
    private void clearMultisigKey() {
      bitField0_ = (bitField0_ & ~0x00000001);
      multisigKey_ = getDefaultInstance().getMultisigKey();
    }

    public static final int MIN_ACCEPTED_CHANNEL_SIZE_FIELD_NUMBER = 2;
    private long minAcceptedChannelSize_;
    /**
     * <pre>
     * Once a channel is exhausted a new one must be set up. So secondary indicates the minimum
     * size it's willing to accept here. This can be lower to trade off resources against
     * security but shouldn't be so low the transactions get rejected by the network as spam.
     * Zero isn't a sensible value to have here, so we make the field required.
     * </pre>
     *
     * <code>required uint64 min_accepted_channel_size = 2;</code>
     */
    public boolean hasMinAcceptedChannelSize() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Once a channel is exhausted a new one must be set up. So secondary indicates the minimum
     * size it's willing to accept here. This can be lower to trade off resources against
     * security but shouldn't be so low the transactions get rejected by the network as spam.
     * Zero isn't a sensible value to have here, so we make the field required.
     * </pre>
     *
     * <code>required uint64 min_accepted_channel_size = 2;</code>
     */
    public long getMinAcceptedChannelSize() {
      return minAcceptedChannelSize_;
    }
    /**
     * <pre>
     * Once a channel is exhausted a new one must be set up. So secondary indicates the minimum
     * size it's willing to accept here. This can be lower to trade off resources against
     * security but shouldn't be so low the transactions get rejected by the network as spam.
     * Zero isn't a sensible value to have here, so we make the field required.
     * </pre>
     *
     * <code>required uint64 min_accepted_channel_size = 2;</code>
     */
    private void setMinAcceptedChannelSize(long value) {
      bitField0_ |= 0x00000002;
      minAcceptedChannelSize_ = value;
    }
    /**
     * <pre>
     * Once a channel is exhausted a new one must be set up. So secondary indicates the minimum
     * size it's willing to accept here. This can be lower to trade off resources against
     * security but shouldn't be so low the transactions get rejected by the network as spam.
     * Zero isn't a sensible value to have here, so we make the field required.
     * </pre>
     *
     * <code>required uint64 min_accepted_channel_size = 2;</code>
     */
    private void clearMinAcceptedChannelSize() {
      bitField0_ = (bitField0_ & ~0x00000002);
      minAcceptedChannelSize_ = 0L;
    }

    public static final int EXPIRE_TIME_SECS_FIELD_NUMBER = 3;
    private long expireTimeSecs_;
    /**
     * <pre>
     * Rough UNIX time for when the channel expires. This is determined by the block header
     * timestamps which can be very inaccurate when miners use the obsolete RollNTime hack.
     * Channels could also be specified in terms of block heights but then how do you know the
     * current chain height if you don't have internet access? Trust the server? Probably opens up
     * attack vectors. We can assume the client has an independent clock, however. If the client
     * considers this value too far off (eg more than a day), it may send an ERROR and close the
     * channel.
     * </pre>
     *
     * <code>required uint64 expire_time_secs = 3;</code>
     */
    public boolean hasExpireTimeSecs() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * Rough UNIX time for when the channel expires. This is determined by the block header
     * timestamps which can be very inaccurate when miners use the obsolete RollNTime hack.
     * Channels could also be specified in terms of block heights but then how do you know the
     * current chain height if you don't have internet access? Trust the server? Probably opens up
     * attack vectors. We can assume the client has an independent clock, however. If the client
     * considers this value too far off (eg more than a day), it may send an ERROR and close the
     * channel.
     * </pre>
     *
     * <code>required uint64 expire_time_secs = 3;</code>
     */
    public long getExpireTimeSecs() {
      return expireTimeSecs_;
    }
    /**
     * <pre>
     * Rough UNIX time for when the channel expires. This is determined by the block header
     * timestamps which can be very inaccurate when miners use the obsolete RollNTime hack.
     * Channels could also be specified in terms of block heights but then how do you know the
     * current chain height if you don't have internet access? Trust the server? Probably opens up
     * attack vectors. We can assume the client has an independent clock, however. If the client
     * considers this value too far off (eg more than a day), it may send an ERROR and close the
     * channel.
     * </pre>
     *
     * <code>required uint64 expire_time_secs = 3;</code>
     */
    private void setExpireTimeSecs(long value) {
      bitField0_ |= 0x00000004;
      expireTimeSecs_ = value;
    }
    /**
     * <pre>
     * Rough UNIX time for when the channel expires. This is determined by the block header
     * timestamps which can be very inaccurate when miners use the obsolete RollNTime hack.
     * Channels could also be specified in terms of block heights but then how do you know the
     * current chain height if you don't have internet access? Trust the server? Probably opens up
     * attack vectors. We can assume the client has an independent clock, however. If the client
     * considers this value too far off (eg more than a day), it may send an ERROR and close the
     * channel.
     * </pre>
     *
     * <code>required uint64 expire_time_secs = 3;</code>
     */
    private void clearExpireTimeSecs() {
      bitField0_ = (bitField0_ & ~0x00000004);
      expireTimeSecs_ = 0L;
    }

    public static final int MIN_PAYMENT_FIELD_NUMBER = 4;
    private long minPayment_;
    /**
     * <pre>
     * The amount of money the server requires for the initial payment. The act of opening a channel
     * always transfers some quantity of money to the server: it's impossible to have a channel with
     * zero value transferred. This rule ensures that you can't get a channel that can't be settled
     * due to having paid under the dust limit. Because the dust limit will float in future, the
     * server tells the client what it thinks it is, and the client is supposed to sanity check this
     * value.
     * </pre>
     *
     * <code>required uint64 min_payment = 4;</code>
     */
    public boolean hasMinPayment() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * The amount of money the server requires for the initial payment. The act of opening a channel
     * always transfers some quantity of money to the server: it's impossible to have a channel with
     * zero value transferred. This rule ensures that you can't get a channel that can't be settled
     * due to having paid under the dust limit. Because the dust limit will float in future, the
     * server tells the client what it thinks it is, and the client is supposed to sanity check this
     * value.
     * </pre>
     *
     * <code>required uint64 min_payment = 4;</code>
     */
    public long getMinPayment() {
      return minPayment_;
    }
    /**
     * <pre>
     * The amount of money the server requires for the initial payment. The act of opening a channel
     * always transfers some quantity of money to the server: it's impossible to have a channel with
     * zero value transferred. This rule ensures that you can't get a channel that can't be settled
     * due to having paid under the dust limit. Because the dust limit will float in future, the
     * server tells the client what it thinks it is, and the client is supposed to sanity check this
     * value.
     * </pre>
     *
     * <code>required uint64 min_payment = 4;</code>
     */
    private void setMinPayment(long value) {
      bitField0_ |= 0x00000008;
      minPayment_ = value;
    }
    /**
     * <pre>
     * The amount of money the server requires for the initial payment. The act of opening a channel
     * always transfers some quantity of money to the server: it's impossible to have a channel with
     * zero value transferred. This rule ensures that you can't get a channel that can't be settled
     * due to having paid under the dust limit. Because the dust limit will float in future, the
     * server tells the client what it thinks it is, and the client is supposed to sanity check this
     * value.
     * </pre>
     *
     * <code>required uint64 min_payment = 4;</code>
     */
    private void clearMinPayment() {
      bitField0_ = (bitField0_ & ~0x00000008);
      minPayment_ = 0L;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, multisigKey_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeUInt64(2, minAcceptedChannelSize_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeUInt64(3, expireTimeSecs_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeUInt64(4, minPayment_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, multisigKey_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(2, minAcceptedChannelSize_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(3, expireTimeSecs_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(4, minPayment_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static org.flo.paymentchannel.Protos.Initiate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.Initiate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.Initiate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.Initiate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.Initiate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.Initiate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.Initiate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.Initiate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.Initiate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.Initiate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.flo.paymentchannel.Protos.Initiate prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * Sent from server to client once version nego is done.
     * </pre>
     *
     * Protobuf type {@code paymentchannels.Initiate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.flo.paymentchannel.Protos.Initiate, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.Initiate)
        org.flo.paymentchannel.Protos.InitiateOrBuilder {
      // Construct using org.flo.paymentchannel.Protos.Initiate.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted. It is used only in the creation of the multisig contract, as outputs are
       * created entirely by the secondary
       * </pre>
       *
       * <code>required bytes multisig_key = 1;</code>
       */
      public boolean hasMultisigKey() {
        return instance.hasMultisigKey();
      }
      /**
       * <pre>
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted. It is used only in the creation of the multisig contract, as outputs are
       * created entirely by the secondary
       * </pre>
       *
       * <code>required bytes multisig_key = 1;</code>
       */
      public com.google.protobuf.ByteString getMultisigKey() {
        return instance.getMultisigKey();
      }
      /**
       * <pre>
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted. It is used only in the creation of the multisig contract, as outputs are
       * created entirely by the secondary
       * </pre>
       *
       * <code>required bytes multisig_key = 1;</code>
       */
      public Builder setMultisigKey(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setMultisigKey(value);
        return this;
      }
      /**
       * <pre>
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted. It is used only in the creation of the multisig contract, as outputs are
       * created entirely by the secondary
       * </pre>
       *
       * <code>required bytes multisig_key = 1;</code>
       */
      public Builder clearMultisigKey() {
        copyOnWrite();
        instance.clearMultisigKey();
        return this;
      }

      /**
       * <pre>
       * Once a channel is exhausted a new one must be set up. So secondary indicates the minimum
       * size it's willing to accept here. This can be lower to trade off resources against
       * security but shouldn't be so low the transactions get rejected by the network as spam.
       * Zero isn't a sensible value to have here, so we make the field required.
       * </pre>
       *
       * <code>required uint64 min_accepted_channel_size = 2;</code>
       */
      public boolean hasMinAcceptedChannelSize() {
        return instance.hasMinAcceptedChannelSize();
      }
      /**
       * <pre>
       * Once a channel is exhausted a new one must be set up. So secondary indicates the minimum
       * size it's willing to accept here. This can be lower to trade off resources against
       * security but shouldn't be so low the transactions get rejected by the network as spam.
       * Zero isn't a sensible value to have here, so we make the field required.
       * </pre>
       *
       * <code>required uint64 min_accepted_channel_size = 2;</code>
       */
      public long getMinAcceptedChannelSize() {
        return instance.getMinAcceptedChannelSize();
      }
      /**
       * <pre>
       * Once a channel is exhausted a new one must be set up. So secondary indicates the minimum
       * size it's willing to accept here. This can be lower to trade off resources against
       * security but shouldn't be so low the transactions get rejected by the network as spam.
       * Zero isn't a sensible value to have here, so we make the field required.
       * </pre>
       *
       * <code>required uint64 min_accepted_channel_size = 2;</code>
       */
      public Builder setMinAcceptedChannelSize(long value) {
        copyOnWrite();
        instance.setMinAcceptedChannelSize(value);
        return this;
      }
      /**
       * <pre>
       * Once a channel is exhausted a new one must be set up. So secondary indicates the minimum
       * size it's willing to accept here. This can be lower to trade off resources against
       * security but shouldn't be so low the transactions get rejected by the network as spam.
       * Zero isn't a sensible value to have here, so we make the field required.
       * </pre>
       *
       * <code>required uint64 min_accepted_channel_size = 2;</code>
       */
      public Builder clearMinAcceptedChannelSize() {
        copyOnWrite();
        instance.clearMinAcceptedChannelSize();
        return this;
      }

      /**
       * <pre>
       * Rough UNIX time for when the channel expires. This is determined by the block header
       * timestamps which can be very inaccurate when miners use the obsolete RollNTime hack.
       * Channels could also be specified in terms of block heights but then how do you know the
       * current chain height if you don't have internet access? Trust the server? Probably opens up
       * attack vectors. We can assume the client has an independent clock, however. If the client
       * considers this value too far off (eg more than a day), it may send an ERROR and close the
       * channel.
       * </pre>
       *
       * <code>required uint64 expire_time_secs = 3;</code>
       */
      public boolean hasExpireTimeSecs() {
        return instance.hasExpireTimeSecs();
      }
      /**
       * <pre>
       * Rough UNIX time for when the channel expires. This is determined by the block header
       * timestamps which can be very inaccurate when miners use the obsolete RollNTime hack.
       * Channels could also be specified in terms of block heights but then how do you know the
       * current chain height if you don't have internet access? Trust the server? Probably opens up
       * attack vectors. We can assume the client has an independent clock, however. If the client
       * considers this value too far off (eg more than a day), it may send an ERROR and close the
       * channel.
       * </pre>
       *
       * <code>required uint64 expire_time_secs = 3;</code>
       */
      public long getExpireTimeSecs() {
        return instance.getExpireTimeSecs();
      }
      /**
       * <pre>
       * Rough UNIX time for when the channel expires. This is determined by the block header
       * timestamps which can be very inaccurate when miners use the obsolete RollNTime hack.
       * Channels could also be specified in terms of block heights but then how do you know the
       * current chain height if you don't have internet access? Trust the server? Probably opens up
       * attack vectors. We can assume the client has an independent clock, however. If the client
       * considers this value too far off (eg more than a day), it may send an ERROR and close the
       * channel.
       * </pre>
       *
       * <code>required uint64 expire_time_secs = 3;</code>
       */
      public Builder setExpireTimeSecs(long value) {
        copyOnWrite();
        instance.setExpireTimeSecs(value);
        return this;
      }
      /**
       * <pre>
       * Rough UNIX time for when the channel expires. This is determined by the block header
       * timestamps which can be very inaccurate when miners use the obsolete RollNTime hack.
       * Channels could also be specified in terms of block heights but then how do you know the
       * current chain height if you don't have internet access? Trust the server? Probably opens up
       * attack vectors. We can assume the client has an independent clock, however. If the client
       * considers this value too far off (eg more than a day), it may send an ERROR and close the
       * channel.
       * </pre>
       *
       * <code>required uint64 expire_time_secs = 3;</code>
       */
      public Builder clearExpireTimeSecs() {
        copyOnWrite();
        instance.clearExpireTimeSecs();
        return this;
      }

      /**
       * <pre>
       * The amount of money the server requires for the initial payment. The act of opening a channel
       * always transfers some quantity of money to the server: it's impossible to have a channel with
       * zero value transferred. This rule ensures that you can't get a channel that can't be settled
       * due to having paid under the dust limit. Because the dust limit will float in future, the
       * server tells the client what it thinks it is, and the client is supposed to sanity check this
       * value.
       * </pre>
       *
       * <code>required uint64 min_payment = 4;</code>
       */
      public boolean hasMinPayment() {
        return instance.hasMinPayment();
      }
      /**
       * <pre>
       * The amount of money the server requires for the initial payment. The act of opening a channel
       * always transfers some quantity of money to the server: it's impossible to have a channel with
       * zero value transferred. This rule ensures that you can't get a channel that can't be settled
       * due to having paid under the dust limit. Because the dust limit will float in future, the
       * server tells the client what it thinks it is, and the client is supposed to sanity check this
       * value.
       * </pre>
       *
       * <code>required uint64 min_payment = 4;</code>
       */
      public long getMinPayment() {
        return instance.getMinPayment();
      }
      /**
       * <pre>
       * The amount of money the server requires for the initial payment. The act of opening a channel
       * always transfers some quantity of money to the server: it's impossible to have a channel with
       * zero value transferred. This rule ensures that you can't get a channel that can't be settled
       * due to having paid under the dust limit. Because the dust limit will float in future, the
       * server tells the client what it thinks it is, and the client is supposed to sanity check this
       * value.
       * </pre>
       *
       * <code>required uint64 min_payment = 4;</code>
       */
      public Builder setMinPayment(long value) {
        copyOnWrite();
        instance.setMinPayment(value);
        return this;
      }
      /**
       * <pre>
       * The amount of money the server requires for the initial payment. The act of opening a channel
       * always transfers some quantity of money to the server: it's impossible to have a channel with
       * zero value transferred. This rule ensures that you can't get a channel that can't be settled
       * due to having paid under the dust limit. Because the dust limit will float in future, the
       * server tells the client what it thinks it is, and the client is supposed to sanity check this
       * value.
       * </pre>
       *
       * <code>required uint64 min_payment = 4;</code>
       */
      public Builder clearMinPayment() {
        copyOnWrite();
        instance.clearMinPayment();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.Initiate)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.flo.paymentchannel.Protos.Initiate();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (!hasMultisigKey()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (!hasMinAcceptedChannelSize()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (!hasExpireTimeSecs()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (!hasMinPayment()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          org.flo.paymentchannel.Protos.Initiate other = (org.flo.paymentchannel.Protos.Initiate) arg1;
          multisigKey_ = visitor.visitByteString(
              hasMultisigKey(), multisigKey_,
              other.hasMultisigKey(), other.multisigKey_);
          minAcceptedChannelSize_ = visitor.visitLong(
              hasMinAcceptedChannelSize(), minAcceptedChannelSize_,
              other.hasMinAcceptedChannelSize(), other.minAcceptedChannelSize_);
          expireTimeSecs_ = visitor.visitLong(
              hasExpireTimeSecs(), expireTimeSecs_,
              other.hasExpireTimeSecs(), other.expireTimeSecs_);
          minPayment_ = visitor.visitLong(
              hasMinPayment(), minPayment_,
              other.hasMinPayment(), other.minPayment_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(tag, input)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  bitField0_ |= 0x00000001;
                  multisigKey_ = input.readBytes();
                  break;
                }
                case 16: {
                  bitField0_ |= 0x00000002;
                  minAcceptedChannelSize_ = input.readUInt64();
                  break;
                }
                case 24: {
                  bitField0_ |= 0x00000004;
                  expireTimeSecs_ = input.readUInt64();
                  break;
                }
                case 32: {
                  bitField0_ |= 0x00000008;
                  minPayment_ = input.readUInt64();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (org.flo.paymentchannel.Protos.Initiate.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.Initiate)
    private static final org.flo.paymentchannel.Protos.Initiate DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Initiate();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static org.flo.paymentchannel.Protos.Initiate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Initiate> PARSER;

    public static com.google.protobuf.Parser<Initiate> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ProvideRefundOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.ProvideRefund)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     */
    boolean hasMultisigKey();
    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     */
    com.google.protobuf.ByteString getMultisigKey();

    /**
     * <pre>
     * The serialized bytes of the return transaction in Satoshi format.
     * * It must have exactly one input which spends the multisig output (see ProvideContract for
     *   details of exactly what that output must look like). This output must have a sequence
     *   number of 0.
     * * It must have the lock time set to a time after the min_time_window_secs (from the
     *   Initiate message).
     * * It must have exactly one output which goes back to the primary.  This output's
     *   scriptPubKey will be reused to create payment transactions.
     * </pre>
     *
     * <code>required bytes tx = 2;</code>
     */
    boolean hasTx();
    /**
     * <pre>
     * The serialized bytes of the return transaction in Satoshi format.
     * * It must have exactly one input which spends the multisig output (see ProvideContract for
     *   details of exactly what that output must look like). This output must have a sequence
     *   number of 0.
     * * It must have the lock time set to a time after the min_time_window_secs (from the
     *   Initiate message).
     * * It must have exactly one output which goes back to the primary.  This output's
     *   scriptPubKey will be reused to create payment transactions.
     * </pre>
     *
     * <code>required bytes tx = 2;</code>
     */
    com.google.protobuf.ByteString getTx();
  }
  /**
   * <pre>
   * Sent from primary to secondary after Initiate to begin the refund transaction signing.
   * </pre>
   *
   * Protobuf type {@code paymentchannels.ProvideRefund}
   */
  public  static final class ProvideRefund extends
      com.google.protobuf.GeneratedMessageLite<
          ProvideRefund, ProvideRefund.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.ProvideRefund)
      ProvideRefundOrBuilder {
    private ProvideRefund() {
      multisigKey_ = com.google.protobuf.ByteString.EMPTY;
      tx_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int MULTISIG_KEY_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString multisigKey_;
    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     */
    public boolean hasMultisigKey() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     */
    public com.google.protobuf.ByteString getMultisigKey() {
      return multisigKey_;
    }
    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     */
    private void setMultisigKey(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
      multisigKey_ = value;
    }
    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     */
    private void clearMultisigKey() {
      bitField0_ = (bitField0_ & ~0x00000001);
      multisigKey_ = getDefaultInstance().getMultisigKey();
    }

    public static final int TX_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString tx_;
    /**
     * <pre>
     * The serialized bytes of the return transaction in Satoshi format.
     * * It must have exactly one input which spends the multisig output (see ProvideContract for
     *   details of exactly what that output must look like). This output must have a sequence
     *   number of 0.
     * * It must have the lock time set to a time after the min_time_window_secs (from the
     *   Initiate message).
     * * It must have exactly one output which goes back to the primary.  This output's
     *   scriptPubKey will be reused to create payment transactions.
     * </pre>
     *
     * <code>required bytes tx = 2;</code>
     */
    public boolean hasTx() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * The serialized bytes of the return transaction in Satoshi format.
     * * It must have exactly one input which spends the multisig output (see ProvideContract for
     *   details of exactly what that output must look like). This output must have a sequence
     *   number of 0.
     * * It must have the lock time set to a time after the min_time_window_secs (from the
     *   Initiate message).
     * * It must have exactly one output which goes back to the primary.  This output's
     *   scriptPubKey will be reused to create payment transactions.
     * </pre>
     *
     * <code>required bytes tx = 2;</code>
     */
    public com.google.protobuf.ByteString getTx() {
      return tx_;
    }
    /**
     * <pre>
     * The serialized bytes of the return transaction in Satoshi format.
     * * It must have exactly one input which spends the multisig output (see ProvideContract for
     *   details of exactly what that output must look like). This output must have a sequence
     *   number of 0.
     * * It must have the lock time set to a time after the min_time_window_secs (from the
     *   Initiate message).
     * * It must have exactly one output which goes back to the primary.  This output's
     *   scriptPubKey will be reused to create payment transactions.
     * </pre>
     *
     * <code>required bytes tx = 2;</code>
     */
    private void setTx(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
      tx_ = value;
    }
    /**
     * <pre>
     * The serialized bytes of the return transaction in Satoshi format.
     * * It must have exactly one input which spends the multisig output (see ProvideContract for
     *   details of exactly what that output must look like). This output must have a sequence
     *   number of 0.
     * * It must have the lock time set to a time after the min_time_window_secs (from the
     *   Initiate message).
     * * It must have exactly one output which goes back to the primary.  This output's
     *   scriptPubKey will be reused to create payment transactions.
     * </pre>
     *
     * <code>required bytes tx = 2;</code>
     */
    private void clearTx() {
      bitField0_ = (bitField0_ & ~0x00000002);
      tx_ = getDefaultInstance().getTx();
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, multisigKey_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBytes(2, tx_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, multisigKey_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, tx_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static org.flo.paymentchannel.Protos.ProvideRefund parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.ProvideRefund parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.ProvideRefund parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.ProvideRefund parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.ProvideRefund parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.ProvideRefund parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.ProvideRefund parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.ProvideRefund parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.ProvideRefund parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.ProvideRefund parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.flo.paymentchannel.Protos.ProvideRefund prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * Sent from primary to secondary after Initiate to begin the refund transaction signing.
     * </pre>
     *
     * Protobuf type {@code paymentchannels.ProvideRefund}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.flo.paymentchannel.Protos.ProvideRefund, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.ProvideRefund)
        org.flo.paymentchannel.Protos.ProvideRefundOrBuilder {
      // Construct using org.flo.paymentchannel.Protos.ProvideRefund.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted.  It is only used in the creation of the multisig contract.
       * </pre>
       *
       * <code>required bytes multisig_key = 1;</code>
       */
      public boolean hasMultisigKey() {
        return instance.hasMultisigKey();
      }
      /**
       * <pre>
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted.  It is only used in the creation of the multisig contract.
       * </pre>
       *
       * <code>required bytes multisig_key = 1;</code>
       */
      public com.google.protobuf.ByteString getMultisigKey() {
        return instance.getMultisigKey();
      }
      /**
       * <pre>
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted.  It is only used in the creation of the multisig contract.
       * </pre>
       *
       * <code>required bytes multisig_key = 1;</code>
       */
      public Builder setMultisigKey(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setMultisigKey(value);
        return this;
      }
      /**
       * <pre>
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted.  It is only used in the creation of the multisig contract.
       * </pre>
       *
       * <code>required bytes multisig_key = 1;</code>
       */
      public Builder clearMultisigKey() {
        copyOnWrite();
        instance.clearMultisigKey();
        return this;
      }

      /**
       * <pre>
       * The serialized bytes of the return transaction in Satoshi format.
       * * It must have exactly one input which spends the multisig output (see ProvideContract for
       *   details of exactly what that output must look like). This output must have a sequence
       *   number of 0.
       * * It must have the lock time set to a time after the min_time_window_secs (from the
       *   Initiate message).
       * * It must have exactly one output which goes back to the primary.  This output's
       *   scriptPubKey will be reused to create payment transactions.
       * </pre>
       *
       * <code>required bytes tx = 2;</code>
       */
      public boolean hasTx() {
        return instance.hasTx();
      }
      /**
       * <pre>
       * The serialized bytes of the return transaction in Satoshi format.
       * * It must have exactly one input which spends the multisig output (see ProvideContract for
       *   details of exactly what that output must look like). This output must have a sequence
       *   number of 0.
       * * It must have the lock time set to a time after the min_time_window_secs (from the
       *   Initiate message).
       * * It must have exactly one output which goes back to the primary.  This output's
       *   scriptPubKey will be reused to create payment transactions.
       * </pre>
       *
       * <code>required bytes tx = 2;</code>
       */
      public com.google.protobuf.ByteString getTx() {
        return instance.getTx();
      }
      /**
       * <pre>
       * The serialized bytes of the return transaction in Satoshi format.
       * * It must have exactly one input which spends the multisig output (see ProvideContract for
       *   details of exactly what that output must look like). This output must have a sequence
       *   number of 0.
       * * It must have the lock time set to a time after the min_time_window_secs (from the
       *   Initiate message).
       * * It must have exactly one output which goes back to the primary.  This output's
       *   scriptPubKey will be reused to create payment transactions.
       * </pre>
       *
       * <code>required bytes tx = 2;</code>
       */
      public Builder setTx(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setTx(value);
        return this;
      }
      /**
       * <pre>
       * The serialized bytes of the return transaction in Satoshi format.
       * * It must have exactly one input which spends the multisig output (see ProvideContract for
       *   details of exactly what that output must look like). This output must have a sequence
       *   number of 0.
       * * It must have the lock time set to a time after the min_time_window_secs (from the
       *   Initiate message).
       * * It must have exactly one output which goes back to the primary.  This output's
       *   scriptPubKey will be reused to create payment transactions.
       * </pre>
       *
       * <code>required bytes tx = 2;</code>
       */
      public Builder clearTx() {
        copyOnWrite();
        instance.clearTx();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.ProvideRefund)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.flo.paymentchannel.Protos.ProvideRefund();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (!hasMultisigKey()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (!hasTx()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          org.flo.paymentchannel.Protos.ProvideRefund other = (org.flo.paymentchannel.Protos.ProvideRefund) arg1;
          multisigKey_ = visitor.visitByteString(
              hasMultisigKey(), multisigKey_,
              other.hasMultisigKey(), other.multisigKey_);
          tx_ = visitor.visitByteString(
              hasTx(), tx_,
              other.hasTx(), other.tx_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(tag, input)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  bitField0_ |= 0x00000001;
                  multisigKey_ = input.readBytes();
                  break;
                }
                case 18: {
                  bitField0_ |= 0x00000002;
                  tx_ = input.readBytes();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (org.flo.paymentchannel.Protos.ProvideRefund.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.ProvideRefund)
    private static final org.flo.paymentchannel.Protos.ProvideRefund DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ProvideRefund();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static org.flo.paymentchannel.Protos.ProvideRefund getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ProvideRefund> PARSER;

    public static com.google.protobuf.Parser<ProvideRefund> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ReturnRefundOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.ReturnRefund)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>required bytes signature = 1;</code>
     */
    boolean hasSignature();
    /**
     * <code>required bytes signature = 1;</code>
     */
    com.google.protobuf.ByteString getSignature();
  }
  /**
   * <pre>
   * Sent from secondary to primary after it has done initial verification of the refund
   * transaction. Contains the primary's signature which is required to spend the multisig contract
   * to the refund transaction. Must be signed using SIGHASH_NONE|SIGHASH_ANYONECANPAY (and include
   * the postfix type byte) to allow the client to add any outputs/inputs it wants as long as the
   * input's sequence and transaction's nLockTime remain set.
   * </pre>
   *
   * Protobuf type {@code paymentchannels.ReturnRefund}
   */
  public  static final class ReturnRefund extends
      com.google.protobuf.GeneratedMessageLite<
          ReturnRefund, ReturnRefund.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.ReturnRefund)
      ReturnRefundOrBuilder {
    private ReturnRefund() {
      signature_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int SIGNATURE_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString signature_;
    /**
     * <code>required bytes signature = 1;</code>
     */
    public boolean hasSignature() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>required bytes signature = 1;</code>
     */
    public com.google.protobuf.ByteString getSignature() {
      return signature_;
    }
    /**
     * <code>required bytes signature = 1;</code>
     */
    private void setSignature(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
      signature_ = value;
    }
    /**
     * <code>required bytes signature = 1;</code>
     */
    private void clearSignature() {
      bitField0_ = (bitField0_ & ~0x00000001);
      signature_ = getDefaultInstance().getSignature();
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, signature_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, signature_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static org.flo.paymentchannel.Protos.ReturnRefund parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.ReturnRefund parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.ReturnRefund parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.ReturnRefund parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.ReturnRefund parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.ReturnRefund parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.ReturnRefund parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.ReturnRefund parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.ReturnRefund parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.ReturnRefund parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.flo.paymentchannel.Protos.ReturnRefund prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * Sent from secondary to primary after it has done initial verification of the refund
     * transaction. Contains the primary's signature which is required to spend the multisig contract
     * to the refund transaction. Must be signed using SIGHASH_NONE|SIGHASH_ANYONECANPAY (and include
     * the postfix type byte) to allow the client to add any outputs/inputs it wants as long as the
     * input's sequence and transaction's nLockTime remain set.
     * </pre>
     *
     * Protobuf type {@code paymentchannels.ReturnRefund}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.flo.paymentchannel.Protos.ReturnRefund, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.ReturnRefund)
        org.flo.paymentchannel.Protos.ReturnRefundOrBuilder {
      // Construct using org.flo.paymentchannel.Protos.ReturnRefund.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>required bytes signature = 1;</code>
       */
      public boolean hasSignature() {
        return instance.hasSignature();
      }
      /**
       * <code>required bytes signature = 1;</code>
       */
      public com.google.protobuf.ByteString getSignature() {
        return instance.getSignature();
      }
      /**
       * <code>required bytes signature = 1;</code>
       */
      public Builder setSignature(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSignature(value);
        return this;
      }
      /**
       * <code>required bytes signature = 1;</code>
       */
      public Builder clearSignature() {
        copyOnWrite();
        instance.clearSignature();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.ReturnRefund)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.flo.paymentchannel.Protos.ReturnRefund();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (!hasSignature()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          org.flo.paymentchannel.Protos.ReturnRefund other = (org.flo.paymentchannel.Protos.ReturnRefund) arg1;
          signature_ = visitor.visitByteString(
              hasSignature(), signature_,
              other.hasSignature(), other.signature_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(tag, input)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  bitField0_ |= 0x00000001;
                  signature_ = input.readBytes();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (org.flo.paymentchannel.Protos.ReturnRefund.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.ReturnRefund)
    private static final org.flo.paymentchannel.Protos.ReturnRefund DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ReturnRefund();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static org.flo.paymentchannel.Protos.ReturnRefund getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ReturnRefund> PARSER;

    public static com.google.protobuf.Parser<ReturnRefund> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ProvideContractOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.ProvideContract)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The serialized bytes of the transaction in Satoshi format.
     * For version 1:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a 2-of-2 multisig output with the first pubkey being the
     *   primary's and the second being the secondary's (ie the script must be exactly "OP_2
     *   ProvideRefund.multisig_key Initiate.multisig_key OP_2 OP_CHECKMULTISIG")
     * For version 2:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a CHECKLOCKTIMEVERIFY output with the first pubkey being the
     *   primary's and the second being the secondary's.
     * </pre>
     *
     * <code>required bytes tx = 1;</code>
     */
    boolean hasTx();
    /**
     * <pre>
     * The serialized bytes of the transaction in Satoshi format.
     * For version 1:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a 2-of-2 multisig output with the first pubkey being the
     *   primary's and the second being the secondary's (ie the script must be exactly "OP_2
     *   ProvideRefund.multisig_key Initiate.multisig_key OP_2 OP_CHECKMULTISIG")
     * For version 2:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a CHECKLOCKTIMEVERIFY output with the first pubkey being the
     *   primary's and the second being the secondary's.
     * </pre>
     *
     * <code>required bytes tx = 1;</code>
     */
    com.google.protobuf.ByteString getTx();

    /**
     * <pre>
     * To open the channel, an initial payment of the server-specified dust limit value must be
     * provided. This ensures that the channel is never in an un-settleable state due to either
     * no payment tx having been provided at all, or a payment that is smaller than the dust
     * limit being provided.
     * </pre>
     *
     * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
     */
    boolean hasInitialPayment();
    /**
     * <pre>
     * To open the channel, an initial payment of the server-specified dust limit value must be
     * provided. This ensures that the channel is never in an un-settleable state due to either
     * no payment tx having been provided at all, or a payment that is smaller than the dust
     * limit being provided.
     * </pre>
     *
     * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
     */
    org.flo.paymentchannel.Protos.UpdatePayment getInitialPayment();

    /**
     * <pre>
     * This field is added in protocol version 2 to send the client public key to the server.
     * In version 1 it isn't used.
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>optional bytes client_key = 3;</code>
     */
    boolean hasClientKey();
    /**
     * <pre>
     * This field is added in protocol version 2 to send the client public key to the server.
     * In version 1 it isn't used.
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>optional bytes client_key = 3;</code>
     */
    com.google.protobuf.ByteString getClientKey();
  }
  /**
   * <pre>
   * Sent from the primary to the secondary to complete initialization.
   * </pre>
   *
   * Protobuf type {@code paymentchannels.ProvideContract}
   */
  public  static final class ProvideContract extends
      com.google.protobuf.GeneratedMessageLite<
          ProvideContract, ProvideContract.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.ProvideContract)
      ProvideContractOrBuilder {
    private ProvideContract() {
      tx_ = com.google.protobuf.ByteString.EMPTY;
      clientKey_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int TX_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString tx_;
    /**
     * <pre>
     * The serialized bytes of the transaction in Satoshi format.
     * For version 1:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a 2-of-2 multisig output with the first pubkey being the
     *   primary's and the second being the secondary's (ie the script must be exactly "OP_2
     *   ProvideRefund.multisig_key Initiate.multisig_key OP_2 OP_CHECKMULTISIG")
     * For version 2:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a CHECKLOCKTIMEVERIFY output with the first pubkey being the
     *   primary's and the second being the secondary's.
     * </pre>
     *
     * <code>required bytes tx = 1;</code>
     */
    public boolean hasTx() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * The serialized bytes of the transaction in Satoshi format.
     * For version 1:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a 2-of-2 multisig output with the first pubkey being the
     *   primary's and the second being the secondary's (ie the script must be exactly "OP_2
     *   ProvideRefund.multisig_key Initiate.multisig_key OP_2 OP_CHECKMULTISIG")
     * For version 2:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a CHECKLOCKTIMEVERIFY output with the first pubkey being the
     *   primary's and the second being the secondary's.
     * </pre>
     *
     * <code>required bytes tx = 1;</code>
     */
    public com.google.protobuf.ByteString getTx() {
      return tx_;
    }
    /**
     * <pre>
     * The serialized bytes of the transaction in Satoshi format.
     * For version 1:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a 2-of-2 multisig output with the first pubkey being the
     *   primary's and the second being the secondary's (ie the script must be exactly "OP_2
     *   ProvideRefund.multisig_key Initiate.multisig_key OP_2 OP_CHECKMULTISIG")
     * For version 2:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a CHECKLOCKTIMEVERIFY output with the first pubkey being the
     *   primary's and the second being the secondary's.
     * </pre>
     *
     * <code>required bytes tx = 1;</code>
     */
    private void setTx(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
      tx_ = value;
    }
    /**
     * <pre>
     * The serialized bytes of the transaction in Satoshi format.
     * For version 1:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a 2-of-2 multisig output with the first pubkey being the
     *   primary's and the second being the secondary's (ie the script must be exactly "OP_2
     *   ProvideRefund.multisig_key Initiate.multisig_key OP_2 OP_CHECKMULTISIG")
     * For version 2:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a CHECKLOCKTIMEVERIFY output with the first pubkey being the
     *   primary's and the second being the secondary's.
     * </pre>
     *
     * <code>required bytes tx = 1;</code>
     */
    private void clearTx() {
      bitField0_ = (bitField0_ & ~0x00000001);
      tx_ = getDefaultInstance().getTx();
    }

    public static final int INITIAL_PAYMENT_FIELD_NUMBER = 2;
    private org.flo.paymentchannel.Protos.UpdatePayment initialPayment_;
    /**
     * <pre>
     * To open the channel, an initial payment of the server-specified dust limit value must be
     * provided. This ensures that the channel is never in an un-settleable state due to either
     * no payment tx having been provided at all, or a payment that is smaller than the dust
     * limit being provided.
     * </pre>
     *
     * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
     */
    public boolean hasInitialPayment() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * To open the channel, an initial payment of the server-specified dust limit value must be
     * provided. This ensures that the channel is never in an un-settleable state due to either
     * no payment tx having been provided at all, or a payment that is smaller than the dust
     * limit being provided.
     * </pre>
     *
     * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
     */
    public org.flo.paymentchannel.Protos.UpdatePayment getInitialPayment() {
      return initialPayment_ == null ? org.flo.paymentchannel.Protos.UpdatePayment.getDefaultInstance() : initialPayment_;
    }
    /**
     * <pre>
     * To open the channel, an initial payment of the server-specified dust limit value must be
     * provided. This ensures that the channel is never in an un-settleable state due to either
     * no payment tx having been provided at all, or a payment that is smaller than the dust
     * limit being provided.
     * </pre>
     *
     * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
     */
    private void setInitialPayment(org.flo.paymentchannel.Protos.UpdatePayment value) {
      if (value == null) {
        throw new NullPointerException();
      }
      initialPayment_ = value;
      bitField0_ |= 0x00000002;
      }
    /**
     * <pre>
     * To open the channel, an initial payment of the server-specified dust limit value must be
     * provided. This ensures that the channel is never in an un-settleable state due to either
     * no payment tx having been provided at all, or a payment that is smaller than the dust
     * limit being provided.
     * </pre>
     *
     * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
     */
    private void setInitialPayment(
        org.flo.paymentchannel.Protos.UpdatePayment.Builder builderForValue) {
      initialPayment_ = builderForValue.build();
      bitField0_ |= 0x00000002;
    }
    /**
     * <pre>
     * To open the channel, an initial payment of the server-specified dust limit value must be
     * provided. This ensures that the channel is never in an un-settleable state due to either
     * no payment tx having been provided at all, or a payment that is smaller than the dust
     * limit being provided.
     * </pre>
     *
     * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
     */
    private void mergeInitialPayment(org.flo.paymentchannel.Protos.UpdatePayment value) {
      if (initialPayment_ != null &&
          initialPayment_ != org.flo.paymentchannel.Protos.UpdatePayment.getDefaultInstance()) {
        initialPayment_ =
          org.flo.paymentchannel.Protos.UpdatePayment.newBuilder(initialPayment_).mergeFrom(value).buildPartial();
      } else {
        initialPayment_ = value;
      }
      bitField0_ |= 0x00000002;
    }
    /**
     * <pre>
     * To open the channel, an initial payment of the server-specified dust limit value must be
     * provided. This ensures that the channel is never in an un-settleable state due to either
     * no payment tx having been provided at all, or a payment that is smaller than the dust
     * limit being provided.
     * </pre>
     *
     * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
     */
    private void clearInitialPayment() {  initialPayment_ = null;
      bitField0_ = (bitField0_ & ~0x00000002);
    }

    public static final int CLIENT_KEY_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString clientKey_;
    /**
     * <pre>
     * This field is added in protocol version 2 to send the client public key to the server.
     * In version 1 it isn't used.
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>optional bytes client_key = 3;</code>
     */
    public boolean hasClientKey() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * This field is added in protocol version 2 to send the client public key to the server.
     * In version 1 it isn't used.
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>optional bytes client_key = 3;</code>
     */
    public com.google.protobuf.ByteString getClientKey() {
      return clientKey_;
    }
    /**
     * <pre>
     * This field is added in protocol version 2 to send the client public key to the server.
     * In version 1 it isn't used.
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>optional bytes client_key = 3;</code>
     */
    private void setClientKey(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
      clientKey_ = value;
    }
    /**
     * <pre>
     * This field is added in protocol version 2 to send the client public key to the server.
     * In version 1 it isn't used.
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>optional bytes client_key = 3;</code>
     */
    private void clearClientKey() {
      bitField0_ = (bitField0_ & ~0x00000004);
      clientKey_ = getDefaultInstance().getClientKey();
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, tx_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getInitialPayment());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBytes(3, clientKey_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, tx_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getInitialPayment());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, clientKey_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static org.flo.paymentchannel.Protos.ProvideContract parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.ProvideContract parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.ProvideContract parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.ProvideContract parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.ProvideContract parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.ProvideContract parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.ProvideContract parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.ProvideContract parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.ProvideContract parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.ProvideContract parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.flo.paymentchannel.Protos.ProvideContract prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * Sent from the primary to the secondary to complete initialization.
     * </pre>
     *
     * Protobuf type {@code paymentchannels.ProvideContract}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.flo.paymentchannel.Protos.ProvideContract, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.ProvideContract)
        org.flo.paymentchannel.Protos.ProvideContractOrBuilder {
      // Construct using org.flo.paymentchannel.Protos.ProvideContract.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The serialized bytes of the transaction in Satoshi format.
       * For version 1:
       * * It must be signed and completely valid and ready for broadcast (ie it includes the
       *   necessary fees) TODO: tell the client how much fee it needs
       * * Its first output must be a 2-of-2 multisig output with the first pubkey being the
       *   primary's and the second being the secondary's (ie the script must be exactly "OP_2
       *   ProvideRefund.multisig_key Initiate.multisig_key OP_2 OP_CHECKMULTISIG")
       * For version 2:
       * * It must be signed and completely valid and ready for broadcast (ie it includes the
       *   necessary fees) TODO: tell the client how much fee it needs
       * * Its first output must be a CHECKLOCKTIMEVERIFY output with the first pubkey being the
       *   primary's and the second being the secondary's.
       * </pre>
       *
       * <code>required bytes tx = 1;</code>
       */
      public boolean hasTx() {
        return instance.hasTx();
      }
      /**
       * <pre>
       * The serialized bytes of the transaction in Satoshi format.
       * For version 1:
       * * It must be signed and completely valid and ready for broadcast (ie it includes the
       *   necessary fees) TODO: tell the client how much fee it needs
       * * Its first output must be a 2-of-2 multisig output with the first pubkey being the
       *   primary's and the second being the secondary's (ie the script must be exactly "OP_2
       *   ProvideRefund.multisig_key Initiate.multisig_key OP_2 OP_CHECKMULTISIG")
       * For version 2:
       * * It must be signed and completely valid and ready for broadcast (ie it includes the
       *   necessary fees) TODO: tell the client how much fee it needs
       * * Its first output must be a CHECKLOCKTIMEVERIFY output with the first pubkey being the
       *   primary's and the second being the secondary's.
       * </pre>
       *
       * <code>required bytes tx = 1;</code>
       */
      public com.google.protobuf.ByteString getTx() {
        return instance.getTx();
      }
      /**
       * <pre>
       * The serialized bytes of the transaction in Satoshi format.
       * For version 1:
       * * It must be signed and completely valid and ready for broadcast (ie it includes the
       *   necessary fees) TODO: tell the client how much fee it needs
       * * Its first output must be a 2-of-2 multisig output with the first pubkey being the
       *   primary's and the second being the secondary's (ie the script must be exactly "OP_2
       *   ProvideRefund.multisig_key Initiate.multisig_key OP_2 OP_CHECKMULTISIG")
       * For version 2:
       * * It must be signed and completely valid and ready for broadcast (ie it includes the
       *   necessary fees) TODO: tell the client how much fee it needs
       * * Its first output must be a CHECKLOCKTIMEVERIFY output with the first pubkey being the
       *   primary's and the second being the secondary's.
       * </pre>
       *
       * <code>required bytes tx = 1;</code>
       */
      public Builder setTx(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setTx(value);
        return this;
      }
      /**
       * <pre>
       * The serialized bytes of the transaction in Satoshi format.
       * For version 1:
       * * It must be signed and completely valid and ready for broadcast (ie it includes the
       *   necessary fees) TODO: tell the client how much fee it needs
       * * Its first output must be a 2-of-2 multisig output with the first pubkey being the
       *   primary's and the second being the secondary's (ie the script must be exactly "OP_2
       *   ProvideRefund.multisig_key Initiate.multisig_key OP_2 OP_CHECKMULTISIG")
       * For version 2:
       * * It must be signed and completely valid and ready for broadcast (ie it includes the
       *   necessary fees) TODO: tell the client how much fee it needs
       * * Its first output must be a CHECKLOCKTIMEVERIFY output with the first pubkey being the
       *   primary's and the second being the secondary's.
       * </pre>
       *
       * <code>required bytes tx = 1;</code>
       */
      public Builder clearTx() {
        copyOnWrite();
        instance.clearTx();
        return this;
      }

      /**
       * <pre>
       * To open the channel, an initial payment of the server-specified dust limit value must be
       * provided. This ensures that the channel is never in an un-settleable state due to either
       * no payment tx having been provided at all, or a payment that is smaller than the dust
       * limit being provided.
       * </pre>
       *
       * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
       */
      public boolean hasInitialPayment() {
        return instance.hasInitialPayment();
      }
      /**
       * <pre>
       * To open the channel, an initial payment of the server-specified dust limit value must be
       * provided. This ensures that the channel is never in an un-settleable state due to either
       * no payment tx having been provided at all, or a payment that is smaller than the dust
       * limit being provided.
       * </pre>
       *
       * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
       */
      public org.flo.paymentchannel.Protos.UpdatePayment getInitialPayment() {
        return instance.getInitialPayment();
      }
      /**
       * <pre>
       * To open the channel, an initial payment of the server-specified dust limit value must be
       * provided. This ensures that the channel is never in an un-settleable state due to either
       * no payment tx having been provided at all, or a payment that is smaller than the dust
       * limit being provided.
       * </pre>
       *
       * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
       */
      public Builder setInitialPayment(org.flo.paymentchannel.Protos.UpdatePayment value) {
        copyOnWrite();
        instance.setInitialPayment(value);
        return this;
        }
      /**
       * <pre>
       * To open the channel, an initial payment of the server-specified dust limit value must be
       * provided. This ensures that the channel is never in an un-settleable state due to either
       * no payment tx having been provided at all, or a payment that is smaller than the dust
       * limit being provided.
       * </pre>
       *
       * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
       */
      public Builder setInitialPayment(
          org.flo.paymentchannel.Protos.UpdatePayment.Builder builderForValue) {
        copyOnWrite();
        instance.setInitialPayment(builderForValue);
        return this;
      }
      /**
       * <pre>
       * To open the channel, an initial payment of the server-specified dust limit value must be
       * provided. This ensures that the channel is never in an un-settleable state due to either
       * no payment tx having been provided at all, or a payment that is smaller than the dust
       * limit being provided.
       * </pre>
       *
       * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
       */
      public Builder mergeInitialPayment(org.flo.paymentchannel.Protos.UpdatePayment value) {
        copyOnWrite();
        instance.mergeInitialPayment(value);
        return this;
      }
      /**
       * <pre>
       * To open the channel, an initial payment of the server-specified dust limit value must be
       * provided. This ensures that the channel is never in an un-settleable state due to either
       * no payment tx having been provided at all, or a payment that is smaller than the dust
       * limit being provided.
       * </pre>
       *
       * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
       */
      public Builder clearInitialPayment() {  copyOnWrite();
        instance.clearInitialPayment();
        return this;
      }

      /**
       * <pre>
       * This field is added in protocol version 2 to send the client public key to the server.
       * In version 1 it isn't used.
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted.  It is only used in the creation of the multisig contract.
       * </pre>
       *
       * <code>optional bytes client_key = 3;</code>
       */
      public boolean hasClientKey() {
        return instance.hasClientKey();
      }
      /**
       * <pre>
       * This field is added in protocol version 2 to send the client public key to the server.
       * In version 1 it isn't used.
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted.  It is only used in the creation of the multisig contract.
       * </pre>
       *
       * <code>optional bytes client_key = 3;</code>
       */
      public com.google.protobuf.ByteString getClientKey() {
        return instance.getClientKey();
      }
      /**
       * <pre>
       * This field is added in protocol version 2 to send the client public key to the server.
       * In version 1 it isn't used.
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted.  It is only used in the creation of the multisig contract.
       * </pre>
       *
       * <code>optional bytes client_key = 3;</code>
       */
      public Builder setClientKey(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setClientKey(value);
        return this;
      }
      /**
       * <pre>
       * This field is added in protocol version 2 to send the client public key to the server.
       * In version 1 it isn't used.
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted.  It is only used in the creation of the multisig contract.
       * </pre>
       *
       * <code>optional bytes client_key = 3;</code>
       */
      public Builder clearClientKey() {
        copyOnWrite();
        instance.clearClientKey();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.ProvideContract)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.flo.paymentchannel.Protos.ProvideContract();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (!hasTx()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (!hasInitialPayment()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (!getInitialPayment().isInitialized()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          org.flo.paymentchannel.Protos.ProvideContract other = (org.flo.paymentchannel.Protos.ProvideContract) arg1;
          tx_ = visitor.visitByteString(
              hasTx(), tx_,
              other.hasTx(), other.tx_);
          initialPayment_ = visitor.visitMessage(initialPayment_, other.initialPayment_);
          clientKey_ = visitor.visitByteString(
              hasClientKey(), clientKey_,
              other.hasClientKey(), other.clientKey_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(tag, input)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  bitField0_ |= 0x00000001;
                  tx_ = input.readBytes();
                  break;
                }
                case 18: {
                  org.flo.paymentchannel.Protos.UpdatePayment.Builder subBuilder = null;
                  if (((bitField0_ & 0x00000002) == 0x00000002)) {
                    subBuilder = initialPayment_.toBuilder();
                  }
                  initialPayment_ = input.readMessage(org.flo.paymentchannel.Protos.UpdatePayment.parser(), extensionRegistry);
                  if (subBuilder != null) {
                    subBuilder.mergeFrom(initialPayment_);
                    initialPayment_ = subBuilder.buildPartial();
                  }
                  bitField0_ |= 0x00000002;
                  break;
                }
                case 26: {
                  bitField0_ |= 0x00000004;
                  clientKey_ = input.readBytes();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (org.flo.paymentchannel.Protos.ProvideContract.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.ProvideContract)
    private static final org.flo.paymentchannel.Protos.ProvideContract DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ProvideContract();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static org.flo.paymentchannel.Protos.ProvideContract getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ProvideContract> PARSER;

    public static com.google.protobuf.Parser<ProvideContract> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface UpdatePaymentOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.UpdatePayment)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The value which is sent back to the primary.  The rest of the multisig output is left for
     * the secondary to do with as they wish.
     * </pre>
     *
     * <code>required uint64 client_change_value = 1;</code>
     */
    boolean hasClientChangeValue();
    /**
     * <pre>
     * The value which is sent back to the primary.  The rest of the multisig output is left for
     * the secondary to do with as they wish.
     * </pre>
     *
     * <code>required uint64 client_change_value = 1;</code>
     */
    long getClientChangeValue();

    /**
     * <pre>
     * A SIGHASH_SINGLE|SIGHASH_ANYONECANPAY signature (including the postfix type byte) which
     * spends the primary's part of the multisig contract's output.  This signature only covers
     * the primary's refund output and thus the secondary is free to do what they wish with their
     * part of the multisig output.
     * </pre>
     *
     * <code>required bytes signature = 2;</code>
     */
    boolean hasSignature();
    /**
     * <pre>
     * A SIGHASH_SINGLE|SIGHASH_ANYONECANPAY signature (including the postfix type byte) which
     * spends the primary's part of the multisig contract's output.  This signature only covers
     * the primary's refund output and thus the secondary is free to do what they wish with their
     * part of the multisig output.
     * </pre>
     *
     * <code>required bytes signature = 2;</code>
     */
    com.google.protobuf.ByteString getSignature();

    /**
     * <pre>
     * Information about this update. Used to extend this protocol.
     * </pre>
     *
     * <code>optional bytes info = 3;</code>
     */
    boolean hasInfo();
    /**
     * <pre>
     * Information about this update. Used to extend this protocol.
     * </pre>
     *
     * <code>optional bytes info = 3;</code>
     */
    com.google.protobuf.ByteString getInfo();
  }
  /**
   * <pre>
   * This message can only be used by the primary after it has received a CHANNEL_OPEN message. It
   * creates a new payment transaction. Note that we don't resubmit the entire TX, this is to avoid
   * (re)parsing bugs and overhead. The payment transaction is created by the primary by:
   * * Adding an input which spends the multisig contract
   * * Setting this input's scriptSig to the given signature and a new signature created by the
   *   primary (the primary should ensure the signature provided correctly spends the multisig
   *   contract)
   * * Adding an output who's scriptPubKey is the same as the refund output (the only output) in
   *   the refund transaction
   * * Setting this output's value to client_change_value (which must be lower than the most recent
   *   client_change_value and lower than the multisig contract's output value)
   * * Adding any number of additional outputs as desired (leaving sufficient fee, if necessary)
   * * Adding any number of additional inputs as desired (eg to add more fee)
   * </pre>
   *
   * Protobuf type {@code paymentchannels.UpdatePayment}
   */
  public  static final class UpdatePayment extends
      com.google.protobuf.GeneratedMessageLite<
          UpdatePayment, UpdatePayment.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.UpdatePayment)
      UpdatePaymentOrBuilder {
    private UpdatePayment() {
      signature_ = com.google.protobuf.ByteString.EMPTY;
      info_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int CLIENT_CHANGE_VALUE_FIELD_NUMBER = 1;
    private long clientChangeValue_;
    /**
     * <pre>
     * The value which is sent back to the primary.  The rest of the multisig output is left for
     * the secondary to do with as they wish.
     * </pre>
     *
     * <code>required uint64 client_change_value = 1;</code>
     */
    public boolean hasClientChangeValue() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * The value which is sent back to the primary.  The rest of the multisig output is left for
     * the secondary to do with as they wish.
     * </pre>
     *
     * <code>required uint64 client_change_value = 1;</code>
     */
    public long getClientChangeValue() {
      return clientChangeValue_;
    }
    /**
     * <pre>
     * The value which is sent back to the primary.  The rest of the multisig output is left for
     * the secondary to do with as they wish.
     * </pre>
     *
     * <code>required uint64 client_change_value = 1;</code>
     */
    private void setClientChangeValue(long value) {
      bitField0_ |= 0x00000001;
      clientChangeValue_ = value;
    }
    /**
     * <pre>
     * The value which is sent back to the primary.  The rest of the multisig output is left for
     * the secondary to do with as they wish.
     * </pre>
     *
     * <code>required uint64 client_change_value = 1;</code>
     */
    private void clearClientChangeValue() {
      bitField0_ = (bitField0_ & ~0x00000001);
      clientChangeValue_ = 0L;
    }

    public static final int SIGNATURE_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString signature_;
    /**
     * <pre>
     * A SIGHASH_SINGLE|SIGHASH_ANYONECANPAY signature (including the postfix type byte) which
     * spends the primary's part of the multisig contract's output.  This signature only covers
     * the primary's refund output and thus the secondary is free to do what they wish with their
     * part of the multisig output.
     * </pre>
     *
     * <code>required bytes signature = 2;</code>
     */
    public boolean hasSignature() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * A SIGHASH_SINGLE|SIGHASH_ANYONECANPAY signature (including the postfix type byte) which
     * spends the primary's part of the multisig contract's output.  This signature only covers
     * the primary's refund output and thus the secondary is free to do what they wish with their
     * part of the multisig output.
     * </pre>
     *
     * <code>required bytes signature = 2;</code>
     */
    public com.google.protobuf.ByteString getSignature() {
      return signature_;
    }
    /**
     * <pre>
     * A SIGHASH_SINGLE|SIGHASH_ANYONECANPAY signature (including the postfix type byte) which
     * spends the primary's part of the multisig contract's output.  This signature only covers
     * the primary's refund output and thus the secondary is free to do what they wish with their
     * part of the multisig output.
     * </pre>
     *
     * <code>required bytes signature = 2;</code>
     */
    private void setSignature(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
      signature_ = value;
    }
    /**
     * <pre>
     * A SIGHASH_SINGLE|SIGHASH_ANYONECANPAY signature (including the postfix type byte) which
     * spends the primary's part of the multisig contract's output.  This signature only covers
     * the primary's refund output and thus the secondary is free to do what they wish with their
     * part of the multisig output.
     * </pre>
     *
     * <code>required bytes signature = 2;</code>
     */
    private void clearSignature() {
      bitField0_ = (bitField0_ & ~0x00000002);
      signature_ = getDefaultInstance().getSignature();
    }

    public static final int INFO_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString info_;
    /**
     * <pre>
     * Information about this update. Used to extend this protocol.
     * </pre>
     *
     * <code>optional bytes info = 3;</code>
     */
    public boolean hasInfo() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * Information about this update. Used to extend this protocol.
     * </pre>
     *
     * <code>optional bytes info = 3;</code>
     */
    public com.google.protobuf.ByteString getInfo() {
      return info_;
    }
    /**
     * <pre>
     * Information about this update. Used to extend this protocol.
     * </pre>
     *
     * <code>optional bytes info = 3;</code>
     */
    private void setInfo(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
      info_ = value;
    }
    /**
     * <pre>
     * Information about this update. Used to extend this protocol.
     * </pre>
     *
     * <code>optional bytes info = 3;</code>
     */
    private void clearInfo() {
      bitField0_ = (bitField0_ & ~0x00000004);
      info_ = getDefaultInstance().getInfo();
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeUInt64(1, clientChangeValue_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBytes(2, signature_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBytes(3, info_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(1, clientChangeValue_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, signature_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, info_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static org.flo.paymentchannel.Protos.UpdatePayment parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.UpdatePayment parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.UpdatePayment parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.UpdatePayment parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.UpdatePayment parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.UpdatePayment parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.UpdatePayment parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.UpdatePayment parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.UpdatePayment parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.UpdatePayment parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.flo.paymentchannel.Protos.UpdatePayment prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * This message can only be used by the primary after it has received a CHANNEL_OPEN message. It
     * creates a new payment transaction. Note that we don't resubmit the entire TX, this is to avoid
     * (re)parsing bugs and overhead. The payment transaction is created by the primary by:
     * * Adding an input which spends the multisig contract
     * * Setting this input's scriptSig to the given signature and a new signature created by the
     *   primary (the primary should ensure the signature provided correctly spends the multisig
     *   contract)
     * * Adding an output who's scriptPubKey is the same as the refund output (the only output) in
     *   the refund transaction
     * * Setting this output's value to client_change_value (which must be lower than the most recent
     *   client_change_value and lower than the multisig contract's output value)
     * * Adding any number of additional outputs as desired (leaving sufficient fee, if necessary)
     * * Adding any number of additional inputs as desired (eg to add more fee)
     * </pre>
     *
     * Protobuf type {@code paymentchannels.UpdatePayment}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.flo.paymentchannel.Protos.UpdatePayment, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.UpdatePayment)
        org.flo.paymentchannel.Protos.UpdatePaymentOrBuilder {
      // Construct using org.flo.paymentchannel.Protos.UpdatePayment.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The value which is sent back to the primary.  The rest of the multisig output is left for
       * the secondary to do with as they wish.
       * </pre>
       *
       * <code>required uint64 client_change_value = 1;</code>
       */
      public boolean hasClientChangeValue() {
        return instance.hasClientChangeValue();
      }
      /**
       * <pre>
       * The value which is sent back to the primary.  The rest of the multisig output is left for
       * the secondary to do with as they wish.
       * </pre>
       *
       * <code>required uint64 client_change_value = 1;</code>
       */
      public long getClientChangeValue() {
        return instance.getClientChangeValue();
      }
      /**
       * <pre>
       * The value which is sent back to the primary.  The rest of the multisig output is left for
       * the secondary to do with as they wish.
       * </pre>
       *
       * <code>required uint64 client_change_value = 1;</code>
       */
      public Builder setClientChangeValue(long value) {
        copyOnWrite();
        instance.setClientChangeValue(value);
        return this;
      }
      /**
       * <pre>
       * The value which is sent back to the primary.  The rest of the multisig output is left for
       * the secondary to do with as they wish.
       * </pre>
       *
       * <code>required uint64 client_change_value = 1;</code>
       */
      public Builder clearClientChangeValue() {
        copyOnWrite();
        instance.clearClientChangeValue();
        return this;
      }

      /**
       * <pre>
       * A SIGHASH_SINGLE|SIGHASH_ANYONECANPAY signature (including the postfix type byte) which
       * spends the primary's part of the multisig contract's output.  This signature only covers
       * the primary's refund output and thus the secondary is free to do what they wish with their
       * part of the multisig output.
       * </pre>
       *
       * <code>required bytes signature = 2;</code>
       */
      public boolean hasSignature() {
        return instance.hasSignature();
      }
      /**
       * <pre>
       * A SIGHASH_SINGLE|SIGHASH_ANYONECANPAY signature (including the postfix type byte) which
       * spends the primary's part of the multisig contract's output.  This signature only covers
       * the primary's refund output and thus the secondary is free to do what they wish with their
       * part of the multisig output.
       * </pre>
       *
       * <code>required bytes signature = 2;</code>
       */
      public com.google.protobuf.ByteString getSignature() {
        return instance.getSignature();
      }
      /**
       * <pre>
       * A SIGHASH_SINGLE|SIGHASH_ANYONECANPAY signature (including the postfix type byte) which
       * spends the primary's part of the multisig contract's output.  This signature only covers
       * the primary's refund output and thus the secondary is free to do what they wish with their
       * part of the multisig output.
       * </pre>
       *
       * <code>required bytes signature = 2;</code>
       */
      public Builder setSignature(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSignature(value);
        return this;
      }
      /**
       * <pre>
       * A SIGHASH_SINGLE|SIGHASH_ANYONECANPAY signature (including the postfix type byte) which
       * spends the primary's part of the multisig contract's output.  This signature only covers
       * the primary's refund output and thus the secondary is free to do what they wish with their
       * part of the multisig output.
       * </pre>
       *
       * <code>required bytes signature = 2;</code>
       */
      public Builder clearSignature() {
        copyOnWrite();
        instance.clearSignature();
        return this;
      }

      /**
       * <pre>
       * Information about this update. Used to extend this protocol.
       * </pre>
       *
       * <code>optional bytes info = 3;</code>
       */
      public boolean hasInfo() {
        return instance.hasInfo();
      }
      /**
       * <pre>
       * Information about this update. Used to extend this protocol.
       * </pre>
       *
       * <code>optional bytes info = 3;</code>
       */
      public com.google.protobuf.ByteString getInfo() {
        return instance.getInfo();
      }
      /**
       * <pre>
       * Information about this update. Used to extend this protocol.
       * </pre>
       *
       * <code>optional bytes info = 3;</code>
       */
      public Builder setInfo(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setInfo(value);
        return this;
      }
      /**
       * <pre>
       * Information about this update. Used to extend this protocol.
       * </pre>
       *
       * <code>optional bytes info = 3;</code>
       */
      public Builder clearInfo() {
        copyOnWrite();
        instance.clearInfo();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.UpdatePayment)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.flo.paymentchannel.Protos.UpdatePayment();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (!hasClientChangeValue()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (!hasSignature()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          org.flo.paymentchannel.Protos.UpdatePayment other = (org.flo.paymentchannel.Protos.UpdatePayment) arg1;
          clientChangeValue_ = visitor.visitLong(
              hasClientChangeValue(), clientChangeValue_,
              other.hasClientChangeValue(), other.clientChangeValue_);
          signature_ = visitor.visitByteString(
              hasSignature(), signature_,
              other.hasSignature(), other.signature_);
          info_ = visitor.visitByteString(
              hasInfo(), info_,
              other.hasInfo(), other.info_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(tag, input)) {
                    done = true;
                  }
                  break;
                }
                case 8: {
                  bitField0_ |= 0x00000001;
                  clientChangeValue_ = input.readUInt64();
                  break;
                }
                case 18: {
                  bitField0_ |= 0x00000002;
                  signature_ = input.readBytes();
                  break;
                }
                case 26: {
                  bitField0_ |= 0x00000004;
                  info_ = input.readBytes();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (org.flo.paymentchannel.Protos.UpdatePayment.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.UpdatePayment)
    private static final org.flo.paymentchannel.Protos.UpdatePayment DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new UpdatePayment();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static org.flo.paymentchannel.Protos.UpdatePayment getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<UpdatePayment> PARSER;

    public static com.google.protobuf.Parser<UpdatePayment> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface PaymentAckOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.PaymentAck)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Information about this update. Used to extend this protocol
     * </pre>
     *
     * <code>optional bytes info = 1;</code>
     */
    boolean hasInfo();
    /**
     * <pre>
     * Information about this update. Used to extend this protocol
     * </pre>
     *
     * <code>optional bytes info = 1;</code>
     */
    com.google.protobuf.ByteString getInfo();
  }
  /**
   * <pre>
   * This message is sent as an acknowledgement of an UpdatePayment message
   * </pre>
   *
   * Protobuf type {@code paymentchannels.PaymentAck}
   */
  public  static final class PaymentAck extends
      com.google.protobuf.GeneratedMessageLite<
          PaymentAck, PaymentAck.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.PaymentAck)
      PaymentAckOrBuilder {
    private PaymentAck() {
      info_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int INFO_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString info_;
    /**
     * <pre>
     * Information about this update. Used to extend this protocol
     * </pre>
     *
     * <code>optional bytes info = 1;</code>
     */
    public boolean hasInfo() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Information about this update. Used to extend this protocol
     * </pre>
     *
     * <code>optional bytes info = 1;</code>
     */
    public com.google.protobuf.ByteString getInfo() {
      return info_;
    }
    /**
     * <pre>
     * Information about this update. Used to extend this protocol
     * </pre>
     *
     * <code>optional bytes info = 1;</code>
     */
    private void setInfo(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
      info_ = value;
    }
    /**
     * <pre>
     * Information about this update. Used to extend this protocol
     * </pre>
     *
     * <code>optional bytes info = 1;</code>
     */
    private void clearInfo() {
      bitField0_ = (bitField0_ & ~0x00000001);
      info_ = getDefaultInstance().getInfo();
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, info_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, info_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static org.flo.paymentchannel.Protos.PaymentAck parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.PaymentAck parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.PaymentAck parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.PaymentAck parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.PaymentAck parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.PaymentAck parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.PaymentAck parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.PaymentAck parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.PaymentAck parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.PaymentAck parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.flo.paymentchannel.Protos.PaymentAck prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * This message is sent as an acknowledgement of an UpdatePayment message
     * </pre>
     *
     * Protobuf type {@code paymentchannels.PaymentAck}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.flo.paymentchannel.Protos.PaymentAck, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.PaymentAck)
        org.flo.paymentchannel.Protos.PaymentAckOrBuilder {
      // Construct using org.flo.paymentchannel.Protos.PaymentAck.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Information about this update. Used to extend this protocol
       * </pre>
       *
       * <code>optional bytes info = 1;</code>
       */
      public boolean hasInfo() {
        return instance.hasInfo();
      }
      /**
       * <pre>
       * Information about this update. Used to extend this protocol
       * </pre>
       *
       * <code>optional bytes info = 1;</code>
       */
      public com.google.protobuf.ByteString getInfo() {
        return instance.getInfo();
      }
      /**
       * <pre>
       * Information about this update. Used to extend this protocol
       * </pre>
       *
       * <code>optional bytes info = 1;</code>
       */
      public Builder setInfo(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setInfo(value);
        return this;
      }
      /**
       * <pre>
       * Information about this update. Used to extend this protocol
       * </pre>
       *
       * <code>optional bytes info = 1;</code>
       */
      public Builder clearInfo() {
        copyOnWrite();
        instance.clearInfo();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.PaymentAck)
    }
    protected final Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.flo.paymentchannel.Protos.PaymentAck();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          org.flo.paymentchannel.Protos.PaymentAck other = (org.flo.paymentchannel.Protos.PaymentAck) arg1;
          info_ = visitor.visitByteString(
              hasInfo(), info_,
              other.hasInfo(), other.info_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(tag, input)) {
                    done = true;
                  }
                  break;
                }
                case 10: {
                  bitField0_ |= 0x00000001;
                  info_ = input.readBytes();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (org.flo.paymentchannel.Protos.PaymentAck.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.PaymentAck)
    private static final org.flo.paymentchannel.Protos.PaymentAck DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new PaymentAck();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static org.flo.paymentchannel.Protos.PaymentAck getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<PaymentAck> PARSER;

    public static com.google.protobuf.Parser<PaymentAck> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface SettlementOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.Settlement)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * A copy of the fully signed final contract that settles the channel. The client can verify
     * the transaction is correct and then commit it to their wallet.
     * </pre>
     *
     * <code>required bytes tx = 3;</code>
     */
    boolean hasTx();
    /**
     * <pre>
     * A copy of the fully signed final contract that settles the channel. The client can verify
     * the transaction is correct and then commit it to their wallet.
     * </pre>
     *
     * <code>required bytes tx = 3;</code>
     */
    com.google.protobuf.ByteString getTx();
  }
  /**
   * Protobuf type {@code paymentchannels.Settlement}
   */
  public  static final class Settlement extends
      com.google.protobuf.GeneratedMessageLite<
          Settlement, Settlement.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.Settlement)
      SettlementOrBuilder {
    private Settlement() {
      tx_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int TX_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString tx_;
    /**
     * <pre>
     * A copy of the fully signed final contract that settles the channel. The client can verify
     * the transaction is correct and then commit it to their wallet.
     * </pre>
     *
     * <code>required bytes tx = 3;</code>
     */
    public boolean hasTx() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * A copy of the fully signed final contract that settles the channel. The client can verify
     * the transaction is correct and then commit it to their wallet.
     * </pre>
     *
     * <code>required bytes tx = 3;</code>
     */
    public com.google.protobuf.ByteString getTx() {
      return tx_;
    }
    /**
     * <pre>
     * A copy of the fully signed final contract that settles the channel. The client can verify
     * the transaction is correct and then commit it to their wallet.
     * </pre>
     *
     * <code>required bytes tx = 3;</code>
     */
    private void setTx(com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
      tx_ = value;
    }
    /**
     * <pre>
     * A copy of the fully signed final contract that settles the channel. The client can verify
     * the transaction is correct and then commit it to their wallet.
     * </pre>
     *
     * <code>required bytes tx = 3;</code>
     */
    private void clearTx() {
      bitField0_ = (bitField0_ & ~0x00000001);
      tx_ = getDefaultInstance().getTx();
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(3, tx_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, tx_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static org.flo.paymentchannel.Protos.Settlement parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.Settlement parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.Settlement parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.Settlement parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.Settlement parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.Settlement parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.Settlement parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.Settlement parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.Settlement parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.Settlement parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.flo.paymentchannel.Protos.Settlement prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * Protobuf type {@code paymentchannels.Settlement}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.flo.paymentchannel.Protos.Settlement, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.Settlement)
        org.flo.paymentchannel.Protos.SettlementOrBuilder {
      // Construct using org.flo.paymentchannel.Protos.Settlement.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * A copy of the fully signed final contract that settles the channel. The client can verify
       * the transaction is correct and then commit it to their wallet.
       * </pre>
       *
       * <code>required bytes tx = 3;</code>
       */
      public boolean hasTx() {
        return instance.hasTx();
      }
      /**
       * <pre>
       * A copy of the fully signed final contract that settles the channel. The client can verify
       * the transaction is correct and then commit it to their wallet.
       * </pre>
       *
       * <code>required bytes tx = 3;</code>
       */
      public com.google.protobuf.ByteString getTx() {
        return instance.getTx();
      }
      /**
       * <pre>
       * A copy of the fully signed final contract that settles the channel. The client can verify
       * the transaction is correct and then commit it to their wallet.
       * </pre>
       *
       * <code>required bytes tx = 3;</code>
       */
      public Builder setTx(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setTx(value);
        return this;
      }
      /**
       * <pre>
       * A copy of the fully signed final contract that settles the channel. The client can verify
       * the transaction is correct and then commit it to their wallet.
       * </pre>
       *
       * <code>required bytes tx = 3;</code>
       */
      public Builder clearTx() {
        copyOnWrite();
        instance.clearTx();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.Settlement)
    }
    private byte memoizedIsInitialized = -1;
    protected final Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.flo.paymentchannel.Protos.Settlement();
        }
        case IS_INITIALIZED: {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return DEFAULT_INSTANCE;
          if (isInitialized == 0) return null;

          boolean shouldMemoize = ((Boolean) arg0).booleanValue();
          if (!hasTx()) {
            if (shouldMemoize) {
              memoizedIsInitialized = 0;
            }
            return null;
          }
          if (shouldMemoize) memoizedIsInitialized = 1;
          return DEFAULT_INSTANCE;

        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          org.flo.paymentchannel.Protos.Settlement other = (org.flo.paymentchannel.Protos.Settlement) arg1;
          tx_ = visitor.visitByteString(
              hasTx(), tx_,
              other.hasTx(), other.tx_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(tag, input)) {
                    done = true;
                  }
                  break;
                }
                case 26: {
                  bitField0_ |= 0x00000001;
                  tx_ = input.readBytes();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (org.flo.paymentchannel.Protos.Settlement.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.Settlement)
    private static final org.flo.paymentchannel.Protos.Settlement DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Settlement();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static org.flo.paymentchannel.Protos.Settlement getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Settlement> PARSER;

    public static com.google.protobuf.Parser<Settlement> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ErrorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.Error)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional .paymentchannels.Error.ErrorCode code = 1 [default = OTHER];</code>
     */
    boolean hasCode();
    /**
     * <code>optional .paymentchannels.Error.ErrorCode code = 1 [default = OTHER];</code>
     */
    org.flo.paymentchannel.Protos.Error.ErrorCode getCode();

    /**
     * <pre>
     * NOT SAFE FOR HTML WITHOUT ESCAPING
     * </pre>
     *
     * <code>optional string explanation = 2;</code>
     */
    boolean hasExplanation();
    /**
     * <pre>
     * NOT SAFE FOR HTML WITHOUT ESCAPING
     * </pre>
     *
     * <code>optional string explanation = 2;</code>
     */
    java.lang.String getExplanation();
    /**
     * <pre>
     * NOT SAFE FOR HTML WITHOUT ESCAPING
     * </pre>
     *
     * <code>optional string explanation = 2;</code>
     */
    com.google.protobuf.ByteString
        getExplanationBytes();

    /**
     * <pre>
     * Can be set by the client when erroring to the server if a value was out of range. Can help with debugging.
     * </pre>
     *
     * <code>optional uint64 expected_value = 3;</code>
     */
    boolean hasExpectedValue();
    /**
     * <pre>
     * Can be set by the client when erroring to the server if a value was out of range. Can help with debugging.
     * </pre>
     *
     * <code>optional uint64 expected_value = 3;</code>
     */
    long getExpectedValue();
  }
  /**
   * <pre>
   * An Error can be sent by either party at any time
   * Both parties should make an effort to send either an ERROR or a CLOSE immediately before
   * closing the socket (unless they just received an ERROR or a CLOSE)
   * </pre>
   *
   * Protobuf type {@code paymentchannels.Error}
   */
  public  static final class Error extends
      com.google.protobuf.GeneratedMessageLite<
          Error, Error.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.Error)
      ErrorOrBuilder {
    private Error() {
      code_ = 8;
      explanation_ = "";
    }
    /**
     * Protobuf enum {@code paymentchannels.Error.ErrorCode}
     */
    public enum ErrorCode
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * Protocol timeout occurred (one party hung).
       * </pre>
       *
       * <code>TIMEOUT = 1;</code>
       */
      TIMEOUT(1),
      /**
       * <pre>
       * Generic error indicating some message was not properly
       * </pre>
       *
       * <code>SYNTAX_ERROR = 2;</code>
       */
      SYNTAX_ERROR(2),
      /**
       * <pre>
       * formatted or was out of order.
       * </pre>
       *
       * <code>NO_ACCEPTABLE_VERSION = 3;</code>
       */
      NO_ACCEPTABLE_VERSION(3),
      /**
       * <pre>
       * A provided transaction was not in the proper structure
       * </pre>
       *
       * <code>BAD_TRANSACTION = 4;</code>
       */
      BAD_TRANSACTION(4),
      /**
       * <pre>
       * (wrong inputs/outputs, sequence, lock time, signature,
       * etc)
       * </pre>
       *
       * <code>TIME_WINDOW_UNACCEPTABLE = 5;</code>
       */
      TIME_WINDOW_UNACCEPTABLE(5),
      /**
       * <pre>
       * for the primary
       * </pre>
       *
       * <code>CHANNEL_VALUE_TOO_LARGE = 6;</code>
       */
      CHANNEL_VALUE_TOO_LARGE(6),
      /**
       * <pre>
       * too large for the primary
       * </pre>
       *
       * <code>MIN_PAYMENT_TOO_LARGE = 7;</code>
       */
      MIN_PAYMENT_TOO_LARGE(7),
      /**
       * <code>OTHER = 8;</code>
       */
      OTHER(8),
      ;

      /**
       * <pre>
       * Protocol timeout occurred (one party hung).
       * </pre>
       *
       * <code>TIMEOUT = 1;</code>
       */
      public static final int TIMEOUT_VALUE = 1;
      /**
       * <pre>
       * Generic error indicating some message was not properly
       * </pre>
       *
       * <code>SYNTAX_ERROR = 2;</code>
       */
      public static final int SYNTAX_ERROR_VALUE = 2;
      /**
       * <pre>
       * formatted or was out of order.
       * </pre>
       *
       * <code>NO_ACCEPTABLE_VERSION = 3;</code>
       */
      public static final int NO_ACCEPTABLE_VERSION_VALUE = 3;
      /**
       * <pre>
       * A provided transaction was not in the proper structure
       * </pre>
       *
       * <code>BAD_TRANSACTION = 4;</code>
       */
      public static final int BAD_TRANSACTION_VALUE = 4;
      /**
       * <pre>
       * (wrong inputs/outputs, sequence, lock time, signature,
       * etc)
       * </pre>
       *
       * <code>TIME_WINDOW_UNACCEPTABLE = 5;</code>
       */
      public static final int TIME_WINDOW_UNACCEPTABLE_VALUE = 5;
      /**
       * <pre>
       * for the primary
       * </pre>
       *
       * <code>CHANNEL_VALUE_TOO_LARGE = 6;</code>
       */
      public static final int CHANNEL_VALUE_TOO_LARGE_VALUE = 6;
      /**
       * <pre>
       * too large for the primary
       * </pre>
       *
       * <code>MIN_PAYMENT_TOO_LARGE = 7;</code>
       */
      public static final int MIN_PAYMENT_TOO_LARGE_VALUE = 7;
      /**
       * <code>OTHER = 8;</code>
       */
      public static final int OTHER_VALUE = 8;


      public final int getNumber() {
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ErrorCode valueOf(int value) {
        return forNumber(value);
      }

      public static ErrorCode forNumber(int value) {
        switch (value) {
          case 1: return TIMEOUT;
          case 2: return SYNTAX_ERROR;
          case 3: return NO_ACCEPTABLE_VERSION;
          case 4: return BAD_TRANSACTION;
          case 5: return TIME_WINDOW_UNACCEPTABLE;
          case 6: return CHANNEL_VALUE_TOO_LARGE;
          case 7: return MIN_PAYMENT_TOO_LARGE;
          case 8: return OTHER;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ErrorCode>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ErrorCode> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ErrorCode>() {
              public ErrorCode findValueByNumber(int number) {
                return ErrorCode.forNumber(number);
              }
            };

      private final int value;

      private ErrorCode(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:paymentchannels.Error.ErrorCode)
    }

    private int bitField0_;
    public static final int CODE_FIELD_NUMBER = 1;
    private int code_;
    /**
     * <code>optional .paymentchannels.Error.ErrorCode code = 1 [default = OTHER];</code>
     */
    public boolean hasCode() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>optional .paymentchannels.Error.ErrorCode code = 1 [default = OTHER];</code>
     */
    public org.flo.paymentchannel.Protos.Error.ErrorCode getCode() {
      org.flo.paymentchannel.Protos.Error.ErrorCode result = org.flo.paymentchannel.Protos.Error.ErrorCode.forNumber(code_);
      return result == null ? org.flo.paymentchannel.Protos.Error.ErrorCode.OTHER : result;
    }
    /**
     * <code>optional .paymentchannels.Error.ErrorCode code = 1 [default = OTHER];</code>
     */
    private void setCode(org.flo.paymentchannel.Protos.Error.ErrorCode value) {
      if (value == null) {
        throw new NullPointerException();
      }
      bitField0_ |= 0x00000001;
      code_ = value.getNumber();
    }
    /**
     * <code>optional .paymentchannels.Error.ErrorCode code = 1 [default = OTHER];</code>
     */
    private void clearCode() {
      bitField0_ = (bitField0_ & ~0x00000001);
      code_ = 8;
    }

    public static final int EXPLANATION_FIELD_NUMBER = 2;
    private java.lang.String explanation_;
    /**
     * <pre>
     * NOT SAFE FOR HTML WITHOUT ESCAPING
     * </pre>
     *
     * <code>optional string explanation = 2;</code>
     */
    public boolean hasExplanation() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * NOT SAFE FOR HTML WITHOUT ESCAPING
     * </pre>
     *
     * <code>optional string explanation = 2;</code>
     */
    public java.lang.String getExplanation() {
      return explanation_;
    }
    /**
     * <pre>
     * NOT SAFE FOR HTML WITHOUT ESCAPING
     * </pre>
     *
     * <code>optional string explanation = 2;</code>
     */
    public com.google.protobuf.ByteString
        getExplanationBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(explanation_);
    }
    /**
     * <pre>
     * NOT SAFE FOR HTML WITHOUT ESCAPING
     * </pre>
     *
     * <code>optional string explanation = 2;</code>
     */
    private void setExplanation(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
      explanation_ = value;
    }
    /**
     * <pre>
     * NOT SAFE FOR HTML WITHOUT ESCAPING
     * </pre>
     *
     * <code>optional string explanation = 2;</code>
     */
    private void clearExplanation() {
      bitField0_ = (bitField0_ & ~0x00000002);
      explanation_ = getDefaultInstance().getExplanation();
    }
    /**
     * <pre>
     * NOT SAFE FOR HTML WITHOUT ESCAPING
     * </pre>
     *
     * <code>optional string explanation = 2;</code>
     */
    private void setExplanationBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
      explanation_ = value.toStringUtf8();
    }

    public static final int EXPECTED_VALUE_FIELD_NUMBER = 3;
    private long expectedValue_;
    /**
     * <pre>
     * Can be set by the client when erroring to the server if a value was out of range. Can help with debugging.
     * </pre>
     *
     * <code>optional uint64 expected_value = 3;</code>
     */
    public boolean hasExpectedValue() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * Can be set by the client when erroring to the server if a value was out of range. Can help with debugging.
     * </pre>
     *
     * <code>optional uint64 expected_value = 3;</code>
     */
    public long getExpectedValue() {
      return expectedValue_;
    }
    /**
     * <pre>
     * Can be set by the client when erroring to the server if a value was out of range. Can help with debugging.
     * </pre>
     *
     * <code>optional uint64 expected_value = 3;</code>
     */
    private void setExpectedValue(long value) {
      bitField0_ |= 0x00000004;
      expectedValue_ = value;
    }
    /**
     * <pre>
     * Can be set by the client when erroring to the server if a value was out of range. Can help with debugging.
     * </pre>
     *
     * <code>optional uint64 expected_value = 3;</code>
     */
    private void clearExpectedValue() {
      bitField0_ = (bitField0_ & ~0x00000004);
      expectedValue_ = 0L;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeEnum(1, code_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeString(2, getExplanation());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeUInt64(3, expectedValue_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, code_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeStringSize(2, getExplanation());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(3, expectedValue_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSerializedSize = size;
      return size;
    }

    public static org.flo.paymentchannel.Protos.Error parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.Error parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.Error parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.flo.paymentchannel.Protos.Error parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.Error parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.Error parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.Error parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.Error parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.flo.paymentchannel.Protos.Error parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.flo.paymentchannel.Protos.Error parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.flo.paymentchannel.Protos.Error prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * An Error can be sent by either party at any time
     * Both parties should make an effort to send either an ERROR or a CLOSE immediately before
     * closing the socket (unless they just received an ERROR or a CLOSE)
     * </pre>
     *
     * Protobuf type {@code paymentchannels.Error}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.flo.paymentchannel.Protos.Error, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.Error)
        org.flo.paymentchannel.Protos.ErrorOrBuilder {
      // Construct using org.flo.paymentchannel.Protos.Error.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional .paymentchannels.Error.ErrorCode code = 1 [default = OTHER];</code>
       */
      public boolean hasCode() {
        return instance.hasCode();
      }
      /**
       * <code>optional .paymentchannels.Error.ErrorCode code = 1 [default = OTHER];</code>
       */
      public org.flo.paymentchannel.Protos.Error.ErrorCode getCode() {
        return instance.getCode();
      }
      /**
       * <code>optional .paymentchannels.Error.ErrorCode code = 1 [default = OTHER];</code>
       */
      public Builder setCode(org.flo.paymentchannel.Protos.Error.ErrorCode value) {
        copyOnWrite();
        instance.setCode(value);
        return this;
      }
      /**
       * <code>optional .paymentchannels.Error.ErrorCode code = 1 [default = OTHER];</code>
       */
      public Builder clearCode() {
        copyOnWrite();
        instance.clearCode();
        return this;
      }

      /**
       * <pre>
       * NOT SAFE FOR HTML WITHOUT ESCAPING
       * </pre>
       *
       * <code>optional string explanation = 2;</code>
       */
      public boolean hasExplanation() {
        return instance.hasExplanation();
      }
      /**
       * <pre>
       * NOT SAFE FOR HTML WITHOUT ESCAPING
       * </pre>
       *
       * <code>optional string explanation = 2;</code>
       */
      public java.lang.String getExplanation() {
        return instance.getExplanation();
      }
      /**
       * <pre>
       * NOT SAFE FOR HTML WITHOUT ESCAPING
       * </pre>
       *
       * <code>optional string explanation = 2;</code>
       */
      public com.google.protobuf.ByteString
          getExplanationBytes() {
        return instance.getExplanationBytes();
      }
      /**
       * <pre>
       * NOT SAFE FOR HTML WITHOUT ESCAPING
       * </pre>
       *
       * <code>optional string explanation = 2;</code>
       */
      public Builder setExplanation(
          java.lang.String value) {
        copyOnWrite();
        instance.setExplanation(value);
        return this;
      }
      /**
       * <pre>
       * NOT SAFE FOR HTML WITHOUT ESCAPING
       * </pre>
       *
       * <code>optional string explanation = 2;</code>
       */
      public Builder clearExplanation() {
        copyOnWrite();
        instance.clearExplanation();
        return this;
      }
      /**
       * <pre>
       * NOT SAFE FOR HTML WITHOUT ESCAPING
       * </pre>
       *
       * <code>optional string explanation = 2;</code>
       */
      public Builder setExplanationBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setExplanationBytes(value);
        return this;
      }

      /**
       * <pre>
       * Can be set by the client when erroring to the server if a value was out of range. Can help with debugging.
       * </pre>
       *
       * <code>optional uint64 expected_value = 3;</code>
       */
      public boolean hasExpectedValue() {
        return instance.hasExpectedValue();
      }
      /**
       * <pre>
       * Can be set by the client when erroring to the server if a value was out of range. Can help with debugging.
       * </pre>
       *
       * <code>optional uint64 expected_value = 3;</code>
       */
      public long getExpectedValue() {
        return instance.getExpectedValue();
      }
      /**
       * <pre>
       * Can be set by the client when erroring to the server if a value was out of range. Can help with debugging.
       * </pre>
       *
       * <code>optional uint64 expected_value = 3;</code>
       */
      public Builder setExpectedValue(long value) {
        copyOnWrite();
        instance.setExpectedValue(value);
        return this;
      }
      /**
       * <pre>
       * Can be set by the client when erroring to the server if a value was out of range. Can help with debugging.
       * </pre>
       *
       * <code>optional uint64 expected_value = 3;</code>
       */
      public Builder clearExpectedValue() {
        copyOnWrite();
        instance.clearExpectedValue();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.Error)
    }
    protected final Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.flo.paymentchannel.Protos.Error();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          org.flo.paymentchannel.Protos.Error other = (org.flo.paymentchannel.Protos.Error) arg1;
          code_ = visitor.visitInt(hasCode(), code_,
              other.hasCode(), other.code_);
          explanation_ = visitor.visitString(
              hasExplanation(), explanation_,
              other.hasExplanation(), other.explanation_);
          expectedValue_ = visitor.visitLong(
              hasExpectedValue(), expectedValue_,
              other.hasExpectedValue(), other.expectedValue_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
            bitField0_ |= other.bitField0_;
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!parseUnknownField(tag, input)) {
                    done = true;
                  }
                  break;
                }
                case 8: {
                  int rawValue = input.readEnum();
                  org.flo.paymentchannel.Protos.Error.ErrorCode value = org.flo.paymentchannel.Protos.Error.ErrorCode.forNumber(rawValue);
                  if (value == null) {
                    super.mergeVarintField(1, rawValue);
                  } else {
                    bitField0_ |= 0x00000001;
                    code_ = rawValue;
                  }
                  break;
                }
                case 18: {
                  String s = input.readString();
                  bitField0_ |= 0x00000002;
                  explanation_ = s;
                  break;
                }
                case 24: {
                  bitField0_ |= 0x00000004;
                  expectedValue_ = input.readUInt64();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (org.flo.paymentchannel.Protos.Error.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.Error)
    private static final org.flo.paymentchannel.Protos.Error DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Error();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static org.flo.paymentchannel.Protos.Error getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Error> PARSER;

    public static com.google.protobuf.Parser<Error> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
